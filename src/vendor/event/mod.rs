//! Vendor-specific events for BlueNRG controllers.
//!
//! The BlueNRG implementation defines several additional events that are packaged as
//! vendor-specific events by the Bluetooth HCI. This module defines those events and functions to
//! deserialize buffers into them.

pub mod response;

use byteorder::{ByteOrder, LittleEndian};
use core::cmp::PartialEq;
use core::convert::{TryFrom, TryInto};
use core::fmt::{Debug, Formatter, Result as FmtResult};
use core::mem;
use core::time::Duration;

use crate::host::PeerAddrType;
pub use crate::types::{ConnectionInterval, ConnectionIntervalError};
pub use crate::{BdAddr, BdAddrType, ConnectionHandle};

/// Vendor-specific events for the STM32WB5x radio coprocessor.
#[allow(clippy::large_enum_variant)]
#[derive(Clone, Copy, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum VendorEvent {
    /// When the radio coprocessor firmware is started normally, it gives this event to the user to
    /// indicate the system has started.
    CoprocessorReady(FirmwareKind),

    /// If the host fails to read events from the controller quickly enough, the controller will
    /// generate this event. This event is never lost; it is inserted as soon as space is available
    /// in the Tx queue.
    EventsLost(EventFlags),

    /// The fault data event is automatically sent after the
    /// [HalInitialized](VendorEvent::HalInitialized) event in case of
    /// [NMI or Hard fault](ResetReason::Crash).
    // CrashReport(FaultData),

    /// This event is generated by the controller when the limited discoverable mode ends due to
    /// timeout (180 seconds).
    GapLimitedDiscoverableTimeout,

    /// This event is generated when the pairing process has completed successfully or a pairing
    /// procedure timeout has occurred or the pairing has failed.  This is to notify the application
    /// that we have paired with a remote device so that it can take further actions or to notify
    /// that a timeout has occurred so that the upper layer can decide to disconnect the link.
    GapPairingComplete(GapPairingComplete),

    /// This event is generated by the Security manager to the application when a pass key is
    /// required for pairing.  When this event is received, the application has to respond with the
    /// `gap_pass_key_response` command.
    GapPassKeyRequest(ConnectionHandle),

    /// This event is generated by the Security manager to the application when the application has
    /// set that authorization is required for reading/writing of attributes. This event will be
    /// generated as soon as the pairing is complete. When this event is received,
    /// `gap_authorization_response` command should be used by the application.
    GapAuthorizationRequest(ConnectionHandle),

    /// This event is generated when the peripheral security request is successfully sent to the
    /// central device.
    GapPeripheralSecurityInitiated,

    /// This event is generated on the peripheral when a `gap_peripheral_security_request` is called
    /// to reestablish the bond with the central device but the central device has lost the
    /// bond. When this event is received, the upper layer has to issue the command
    /// `gap_allow_rebond` in order to allow the peripheral to continue the pairing process with the
    /// central device. On the central device, this event is raised when `gap_send_pairing_request`
    /// is called to reestablish a bond with a peripheral but the peripheral has lost the bond. In
    /// order to create a new bond the central device has to launch `gap_send_pairing_request` with
    /// `force_rebond` set to `true`.
    GapBondLost,

    /// The event is given by the GAP layer to the upper layers when a device is discovered during
    /// scanning as a consequence of one of the GAP procedures started by the upper layers.
    GapDeviceFound(GapDeviceFound),

    /// This event is sent by the GAP to the upper layers when a procedure previously started has
    /// been terminated by the upper layer or has completed for any other reason
    GapProcedureComplete(GapProcedureComplete),

    /// This event is sent only by a privacy enabled peripheral. with a non-empty bonded device list
    ///  The event is sent to the application when the peripheral is unsuccessful in resolving
    /// the resolvable address of the peer device after connecting to it.
    GapAddressNotResolved(ConnectionHandle),

    /// This event is sent only during SC Pairing, when Numeric Comparison
    /// Association model is selected, in order to show the Numeric Value generated,
    /// and to ask for Confirmation to the User. When this event is received, the
    /// application has to respond with the
    /// [numeric_comparison_value_confirm_yes_no](super::command::gap::GapCommands::numeric_comparison_value_confirm_yes_no)
    /// command.
    GapNumericComparisonValue(GapNumericComparisonValue),

    /// This event is sent only during SC Pairing, when Keypress Notifications are
    /// supported, in order to show the input type signaled by the peer device,
    /// having Keyboard only I/O capabilities. When this event is received, no
    /// action is required to the User.
    GapKeypressNotification(GapKeypressNotification),

    /// This event is generated when the central device responds to the L2CAP connection update
    /// request packet. For more info see
    /// [ConnectionParameterUpdateResponse](crate::vendor::command::l2cap::ConnectionParameterUpdateResponse)
    /// and CommandReject in Bluetooth Core v4.0 spec.
    L2CapConnectionUpdateResponse(L2CapConnectionUpdateResponse),

    /// This event is generated when the central device does not respond to the connection update
    /// request within 30 seconds.
    L2CapProcedureTimeout(ConnectionHandle),

    /// The event is given by the L2CAP layer when a connection update request is received from the
    /// peripheral. The application has to respond by calling
    /// [l2cap_connection_parameter_update_response](crate::vendor::command::l2cap::L2capCommands::connection_parameter_update_response).
    L2CapConnectionUpdateRequest(L2CapConnectionUpdateRequest),

    /// This event is generated upon receipt of a valid Command Reject packet (e.g.
    /// when the Central responds to the Connection Update Request packet with a
    /// Command Reject packet).
    L2CapCommandReject(L2CapCommandReject),

    /// This event is generated when receiving a valid Credit Based Connection Request packet.
    ///
    /// See Bluetooth spec. v.5.4 [Vol 3, Part A].
    L2CapCocConnect(CocConnectEvent),

    /// This event is generated when receiving a valid Credit Based Connection Response packet.
    ///
    /// See Bluetooth spec. v.5.4 [Vol 3, Part A].
    L2CapCocConnectConfirm(CocConnectConfirmEvent),

    /// This event is generated when receiving a valid Credit Based Reconfigure Request packet.
    ///
    /// See Bluetooth spec. v.5.4 [Vol 3, Part A].
    L2CapCocReconfig(CocReconfigEvent),

    /// This event is generated when receiving a valid Credit Based Reconfigure Response packet.
    ///
    /// See Bluetooth spec. v.5.4 [Vol 3, Part A].
    L2CapCocReconfigConfirm(CocReconfigConfirmEvent),

    /// This event is generated when a connection-oriented channel is disconnected following an
    /// L2CAP channel termination procedure.
    ///
    /// Includes the channel index of the connection oriented channel for which the primitive applies
    ///
    /// See Bluetooth spec. v.5.4 [Vol 3, Part A].
    L2CapCocDisconnect(u8),

    /// This event is generated when receiving a valid Flow Control Credit signaling packet.
    ///
    /// See Bluetooth spec. v.5.4 [Vol 3, Part A].
    L2CapCocFlowControl(CocFlowControlEvent),

    /// This event is generated when receiving a valid K-frame packet on a connection-oriented channel
    ///
    /// See Bluetooth spec. v.5.4 [Vol 3, Part A].
    ///
    /// # Note:
    /// For the first K-frame of the SDU, the information data contains the L2CAP SDU length coded in
    /// two octets followed by the K-frame information payload. For the next K-frames of the SDU, the
    /// information data only contains the K-frame information payload.
    L2CapCocRxData(CocRxDataEvent),

    /// Each time the [L2CAO COC Tx Data](crate::vendor::command::l2cap::L2capCommands::coc_tx_data) command
    /// raises the error code [Insufficient Resources](VendorStatus::InsufficientResources) (0x64), this event
    /// is generated as soon as there is a free buffer available for sending K-frames.
    L2CapCocTxPoolAvailable,

    /// This event is generated to the application by the ATT server when a client modifies any
    /// attribute on the server, as consequence of one of the following ATT procedures:
    /// - write without response
    /// - signed write without response
    /// - write characteristic value
    /// - write long characteristic value
    /// - reliable write
    GattAttributeModified(GattAttributeModified),

    /// This event is generated when a ATT client procedure completes either with error or
    /// successfully.
    GattProcedureTimeout(ConnectionHandle),

    /// This event is generated in response to an Exchange MTU request.
    AttExchangeMtuResponse(AttExchangeMtuResponse),

    /// This event is generated in response to a Find Information Request. See Find Information
    /// Response in Bluetooth Core v4.0 spec.
    AttFindInformationResponse(AttFindInformationResponse),

    /// This event is generated in response to a Find By Type Value Request.
    AttFindByTypeValueResponse(AttFindByTypeValueResponse),

    /// This event is generated in response to a Read by Type Request.
    AttReadByTypeResponse(AttReadByTypeResponse),

    /// This event is generated in response to a Read Request.
    AttReadResponse(AttReadResponse),

    /// This event is generated in response to a Read Blob Request. The value in the response is the
    /// partial value starting from the offset in the request. See the Bluetooth Core v4.1 spec, Vol
    /// 3, section 3.4.4.5 and 3.4.4.6.
    AttReadBlobResponse(AttReadResponse),

    /// This event is generated in response to a Read Multiple Request. The value in the response is
    /// the set of values requested from the request. See the Bluetooth Core v4.1 spec, Vol 3,
    /// section 3.4.4.7 and 3.4.4.8.
    AttReadMultipleResponse(AttReadResponse),

    /// This event is generated in response to a Read By Group Type Request. See the Bluetooth Core
    /// v4.1 spec, Vol 3, section 3.4.4.9 and 3.4.4.10.
    AttReadByGroupTypeResponse(AttReadByGroupTypeResponse),

    /// This event is generated in response to a Prepare Write Request. See the Bluetooth Core v4.1
    /// spec, Vol 3, Part F, section 3.4.6.1 and 3.4.6.2
    AttPrepareWriteResponse(AttPrepareWriteResponse),

    /// This event is generated in response to an Execute Write Request. See the Bluetooth Core v4.1
    /// spec, Vol 3, Part F, section 3.4.6.3 and 3.4.6.4
    AttExecuteWriteResponse(ConnectionHandle),

    /// This event is generated when an indication is received from the server.
    GattIndication(AttributeValue),

    /// This event is generated when an notification is received from the server.
    GattNotification(AttributeValue),

    /// This event is generated when a GATT client procedure completes either with error or
    /// successfully.
    GattProcedureComplete(GattProcedureComplete),

    /// This event is generated when an Error Response is received from the server. The error
    /// response can be given by the server at the end of one of the GATT discovery procedures. This
    /// does not mean that the procedure ended with an error, but this error event is part of the
    /// procedure itself.
    AttErrorResponse(AttErrorResponse),

    /// This event can be generated during a "Discover Characteristics by UUID" procedure or a "Read
    /// using Characteristic UUID" procedure. The attribute value will be a service declaration as
    /// defined in Bluetooth Core v4.0 spec, Vol 3, Part G, section 3.3.1), when a "Discover
    /// Characteristics By UUID" has been started. It will be the value of the Characteristic if a
    /// "Read using Characteristic UUID" has been performed.
    ///
    /// See the Bluetooth Core v4.1 spec, Vol 3, Part G, section 4.6.2 (discover characteristics by
    /// UUID), and section 4.8.2 (read using characteristic using UUID).
    GattDiscoverOrReadCharacteristicByUuidResponse(AttributeValue),

    /// This event is given to the application when a write request, write command or signed write
    /// command is received by the server from the client. This event will be given to the
    /// application only if the event bit for this event generation is set when the characteristic
    /// was added. When this event is received, the application has to check whether the value being
    /// requested for write is allowed to be written and respond with a GATT Write Response. If the
    /// write is rejected by the application, then the value of the attribute will not be
    /// modified. In case of a write request, an error response will be sent to the client, with the
    /// error code as specified by the application. In case of write/signed write commands, no
    /// response is sent to the client but the attribute is not modified.
    ///
    /// See the Bluetooth Core v4.1 spec, Vol 3, Part F, section 3.4.5.
    AttWritePermitRequest(AttributeValue),

    /// This event is given to the application when a read request or read blob request is received
    /// by the server from the client. This event will be given to the application only if the event
    /// bit for this event generation is set when the characteristic was added. On receiving this
    /// event, the application can update the value of the handle if it desires and when done it has
    /// to use the [`allow_read`](crate::vendor::command::gatt::GattCommands::allow_read) command to indicate to the
    /// stack that it can send the response to the client.
    ///
    /// See the Bluetooth Core v4.1 spec, Vol 3, Part F, section 3.4.4.
    AttReadPermitRequest(AttReadPermitRequest),

    /// This event is given to the application when a read multiple request or read by type request
    /// is received by the server from the client. This event will be given to the application only
    /// if the event bit for this event generation is set when the characteristic was added.  On
    /// receiving this event, the application can update the values of the handles if it desires and
    /// when done it has to send the [`allow_read`](crate::vendor::command::gatt::GattCommands::allow_read) command to
    /// indicate to the stack that it can send the response to the client.
    ///
    /// See the Bluetooth Core v4.1 spec, Vol 3, Part F, section 3.4.4.
    AttReadMultiplePermitRequest(AttReadMultiplePermitRequest),

    /// This event is raised when the number of available TX buffers is above a threshold TH (TH =
    /// 2).  The event will be given only if a previous ACI command returned with
    /// [InsufficientResources](AttError::InsufficientResources).  On receiving this event, the
    /// application can continue to send notifications by calling `gatt_update_char_value`.
    GattTxPoolAvailable(GattTxPoolAvailable),

    /// This event is raised on the server when the client confirms the reception of an indication.
    GattServerConfirmation(ConnectionHandle),

    /// This event is given to the application when a prepare write request is received by the
    /// server from the client. This event will be given to the application only if the event bit
    /// for this event generation is set when the characteristic was added.  When this event is
    /// received, the application has to check whether the value being requested for write is
    /// allowed to be written and respond with the command `gatt_write_response`.  Based on the
    /// response from the application, the attribute value will be modified by the stack.  If the
    /// write is rejected by the application, then the value of the attribute will not be modified
    /// and an error response will be sent to the client, with the error code as specified by the
    /// application.
    AttPrepareWritePermitRequest(AttPrepareWritePermitRequest),

    /// This event informs the application of a change in status of the enhanced ATT bearer handled
    /// by the special L2CAP channel.
    GattEattBrearer(GattEattBrearer),

    /// This event is generated when a Multiple Handle Value Notification is received from the server.
    GattMultiNotification(GattMultiNotification),

    /// This event is generated on server side after the transmission of all notifications linked with
    /// the a local update of a characteristic value (if it is enabled at the creation of the characteristic
    /// with [GATT Notify Notification Completion](crate::vendor::command::gatt::CharacteristicEvent) mask
    /// and if the characteristic supports notifications).
    GattNotificationComplete(AttributeHandle),

    /// When it is enabled with [set_event_mast](crate::vendor::command::gatt::GattCommands::set_event_mask),
    /// this event is generated instead of [ATT Read Response](VendorEvent::AttReadResponse) /
    /// [ATT Read Blob Response](VendorEvent::AttReadBlobResponse) /
    /// [ATT Read Multiple Response](VendorEvent::AttReadMultipleResponse).
    ///
    /// This event should be used instead of those events when `ATT_MTU >
    /// (BLE_EVT_MAX_PARAM_LEN - 4)` i.e. `ATT_MTU > 251` for `BLE_EVT_MAX_PARAM_LEN`
    /// default value.
    GattReadExt(GattReadExt),

    /// When it is enabled with [set_event_mast](crate::vendor::command::gatt::GattCommands::set_event_mask),
    /// this event is generated instead of [GATT Indication](VendorEvent::GattIndication) event.
    ///
    /// This event should be used instead of `ACI_GATT_INDICATION_EVENT` when `ATT_MTU
    /// > (BLE_EVT_MAX_PARAM_LEN - 4)` i.e. `ATT_MTU > 251` for `BLE_EVT_MAX_PARAM_LEN`
    /// default value.
    GattIndicationExt(AttributeValueExt),

    /// When it is enabled with [set_event_mast](crate::vendor::command::gatt::GattCommands::set_event_mask),
    /// this event is generated instead of [GATT Notification](VendorEvent::GattNotification) event.
    ///
    /// This event should be used instead of `ACI_GATT_INDICATION_EVENT` when `ATT_MTU
    /// > (BLE_EVT_MAX_PARAM_LEN - 4)` i.e. `ATT_MTU > 251` for `BLE_EVT_MAX_PARAM_LEN`
    /// default value.
    GattNotificationExt(AttributeValueExt),

    /// This event is generated when teh device completes a radio activity and provide information when
    /// a new radio activity will be performed.
    ///
    /// Information provided includes type of radio activity and absolute time in system ticks when a
    /// radio acitivity is scheduled, if any. The application can use this information to schedule user
    /// activities synchronous to selected radio activities. A command
    /// [Set Radio Activity Mask](crate::vendor::command::hal::HalCommands::set_radio_activity_mask) is
    /// provided to enable radio activity events of user interests, by default no events are enabled.
    ///
    /// The user should take into account that enabling radio events in an application with intense
    /// radio activity could lead to a fairly high rate of events generated.
    ///
    /// Application use cases indlude synchronizing notifications with connection intervals, switching
    /// antenna at the end of advertising or performing flash erase while radio is idle.
    HalEndOfRadioActivity(HalEndOfRadioActivity),

    /// This event is reported to the application after a scan request is received and a scan response is
    /// scheduled to be transmitted.
    ///
    /// Note: RSSI in this event is valid only when privacy is not used
    HalScanReqReport(HalScanReqReport),

    /// This event is generated to report firmware error information
    HalFirmwareError(HalFirmwareError),
}

/// Enumeration of vendor-specific status codes.
#[derive(Copy, Clone, Debug, PartialEq)]
#[repr(u8)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum VendorStatus {
    /// The command cannot be executed due to the current state of the device.
    Failed = 0x41,
    /// Some parameters are invalid.
    InvalidParameters = 0x42,
    /// It is not allowed to start the procedure (e.g. another the procedure is ongoing or cannot be
    /// started on the given handle).
    NotAllowed = 0x46,
    /// Unexpected error.
    Error = 0x47,
    /// The address was not resolved.
    AddressNotResolved = 0x48,
    /// Failed to read from flash.
    FlashReadFailed = 0x49,
    /// Failed to write to flash.
    FlashWriteFailed = 0x4A,
    /// Failed to erase flash.
    FlashEraseFailed = 0x4B,
    /// Invalid CID
    InvalidCid = 0x50,
    /// Timer is not valid
    TimerNotValidLayer = 0x54,
    /// Insufficient resources to create the timer
    TimerInsufficientResources = 0x55,
    /// Connection signature resolving key (CSRK) is not found.
    CsrkNotFound = 0x5A,
    /// Identity resolving key (IRK) is not found
    IrkNotFound = 0x5B,
    /// The device is not in the security database.
    DeviceNotFoundInDatabase = 0x5C,
    /// The security database is full.
    SecurityDatabaseFull = 0x5D,
    /// The device is not bonded.
    DeviceNotBonded = 0x5E,
    /// The device is blacklisted.
    DeviceInBlacklist = 0x5F,
    /// The handle (service, characteristic, or descriptor) is invalid.
    InvalidHandle = 0x60,
    /// A parameter is invalid
    InvalidParameter = 0x61,
    /// The characteristic handle is not part of the service.
    OutOfHandle = 0x62,
    /// The operation is invalid
    InvalidOperation = 0x63,
    /// Insufficient resources to complete the operation.
    InsufficientResources = 0x64,
    /// The encryption key size is too small
    InsufficientEncryptionKeySize = 0x65,
    /// The characteristic already exists.
    CharacteristicAlreadyExists = 0x66,
    /// Returned when no valid slots are available (e.g. when there are no available state
    /// machines).
    NoValidSlot = 0x82,
    /// Returned when a scan window shorter than minimum allowed value has been requested
    /// (i.e. 2ms). The Rust API should prevent this error from occurring.
    ScanWindowTooShort = 0x83,
    /// Returned when the maximum requested interval to be allocated is shorter then the current
    /// anchor period and a there is no submultiple for the current anchor period that is between
    /// the minimum and the maximum requested intervals.
    NewIntervalFailed = 0x84,
    /// Returned when the maximum requested interval to be allocated is greater than the current
    /// anchor period and there is no multiple of the anchor period that is between the minimum and
    /// the maximum requested intervals.
    IntervalTooLarge = 0x85,
    /// Returned when the current anchor period or a new one can be found that is compatible to the
    /// interval range requested by the new slot but the maximum available length that can be
    /// allocated is less than the minimum requested slot length.
    LengthFailed = 0x86,
    /// MCU Library timed out.
    Timeout = 0xFF,
    /// MCU library: profile already initialized.
    ProfileAlreadyInitialized = 0xF0,
    /// MCU library: A parameter was null.
    NullParameter = 0xF1,
}

impl TryFrom<u8> for VendorStatus {
    type Error = crate::BadStatusError;

    fn try_from(value: u8) -> Result<Self, <Self as TryFrom<u8>>::Error> {
        match value {
            0x41 => Ok(VendorStatus::Failed),
            0x42 => Ok(VendorStatus::InvalidParameters),
            0x46 => Ok(VendorStatus::NotAllowed),
            0x47 => Ok(VendorStatus::Error),
            0x48 => Ok(VendorStatus::AddressNotResolved),
            0x49 => Ok(VendorStatus::FlashReadFailed),
            0x4A => Ok(VendorStatus::FlashWriteFailed),
            0x4B => Ok(VendorStatus::FlashEraseFailed),
            0x50 => Ok(VendorStatus::InvalidCid),
            0x54 => Ok(VendorStatus::TimerNotValidLayer),
            0x55 => Ok(VendorStatus::TimerInsufficientResources),
            0x5A => Ok(VendorStatus::CsrkNotFound),
            0x5B => Ok(VendorStatus::IrkNotFound),
            0x5C => Ok(VendorStatus::DeviceNotFoundInDatabase),
            0x5D => Ok(VendorStatus::SecurityDatabaseFull),
            0x5E => Ok(VendorStatus::DeviceNotBonded),
            0x5F => Ok(VendorStatus::DeviceInBlacklist),
            0x60 => Ok(VendorStatus::InvalidHandle),
            0x61 => Ok(VendorStatus::InvalidParameter),
            0x62 => Ok(VendorStatus::OutOfHandle),
            0x63 => Ok(VendorStatus::InvalidOperation),
            0x64 => Ok(VendorStatus::InsufficientResources),
            0x65 => Ok(VendorStatus::InsufficientEncryptionKeySize),
            0x66 => Ok(VendorStatus::CharacteristicAlreadyExists),
            0x82 => Ok(VendorStatus::NoValidSlot),
            0x83 => Ok(VendorStatus::ScanWindowTooShort),
            0x84 => Ok(VendorStatus::NewIntervalFailed),
            0x85 => Ok(VendorStatus::IntervalTooLarge),
            0x86 => Ok(VendorStatus::LengthFailed),
            0xFF => Ok(VendorStatus::Timeout),
            0xF0 => Ok(VendorStatus::ProfileAlreadyInitialized),
            0xF1 => Ok(VendorStatus::NullParameter),
            _ => Err(crate::BadStatusError::BadValue(value)),
        }
    }
}

impl From<VendorStatus> for u8 {
    fn from(val: VendorStatus) -> Self {
        val as u8
    }
}

/// Enumeration of potential errors when sending commands or deserializing events.
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum VendorError {
    /// The event is not recognized. Includes the unknown opcode.
    UnknownEvent(u16),

    /// For the [CoprocessorReady](VendorEvent::CoprocessorReady) event: the kind of firmware
    /// running on radio coprocessor is not recognized.
    UnknownFirmwareKind(u8),

    /// For the [GAP Pairing Complete](VendorEvent::GapPairingComplete) event: The status was not
    /// recognized. Includes the unrecognized byte.
    BadGapPairingStatus(u8),

    /// For the [GAP Pairing Complete](VendorEvent::GapPairingComplete) event: The error reason
    /// was not recognized. Includes the unrecognized byte.
    BadGapPairingErrorReason(u8),

    /// For the [GAP Device Found](VendorEvent::GapDeviceFound) event: the type of event was not
    /// recognized. Includes the unrecognized byte.
    BadGapDeviceFoundEvent(u8),

    /// For the [GAP Device Found](VendorEvent::GapDeviceFound) event: the type of BDADDR was not
    /// recognized. Includes the unrecognized byte.
    BadGapBdAddrType(u8),

    /// For the [GAP Procedure Complete](VendorEvent::GapProcedureComplete) event: The procedure
    /// code was not recognized. Includes the unrecognized byte.
    BadGapProcedure(u8),

    /// For the [GAP Procedure Complete](VendorEvent::GapProcedureComplete) event: The procedure
    /// status was not recognized. Includes the unrecognized byte.
    BadGapProcedureStatus(u8),

    /// For any L2CAP event: The event data length did not match the expected length. The first
    /// field is the required length, and the second is the actual length.
    BadL2CapDataLength(u8, u8),

    /// For any L2CAP event: The L2CAP length did not match the expected length. The first field is
    /// the required length, and the second is the actual length.
    BadL2CapLength(u16, u16),

    /// For any L2CAP response event: The L2CAP command was rejected, but the rejection reason was
    /// not recognized. Includes the unknown value.
    BadL2CapRejectionReason(u16),

    /// For the [L2CAP Connection Update Response](VendorEvent::L2CapConnectionUpdateResponse)
    /// event: The code byte did not indicate either Rejected or Updated. Includes the invalid byte.
    BadL2CapConnectionResponseCode(u8),

    /// For the [L2CAP Connection Update Response](VendorEvent::L2CapConnectionUpdateResponse)
    /// event: The command was accepted, but the result was not recognized. It did not indicate the
    /// parameters were either updated or rejected. Includes the unknown value.
    BadL2CapConnectionResponseResult(u16),

    /// For the [L2CAP Connection Update Request](VendorEvent::L2CapConnectionUpdateRequest) event:
    /// The provided connection interval is invalid. Includes the underlying error.
    BadConnectionInterval(ConnectionIntervalError),

    /// For the [L2CAP Connection Update Request](VendorEvent::L2CapConnectionUpdateRequest) event:
    /// The provided interval is invalid. Potential errors:
    /// - Either the minimum or maximum is out of range. The minimum value for either is 7.5 ms, and
    ///   the maximum is 4 s.
    /// - The min is greater than the max
    ///
    /// See the Bluetooth specification, Vol 3, Part A, Section 4.20. Versions 4.1, 4.2 and 5.0.
    ///
    /// Inclues the provided minimum and maximum, respectively.
    BadL2CapConnectionUpdateRequestInterval(Duration, Duration),

    /// For the [L2CAP Connection Update Request](VendorEvent::L2CapConnectionUpdateRequest) event:
    /// The provided connection latency is invalid. The maximum value for connection latency is
    /// defined in terms of the timeout and maximum connection interval.
    /// - `connIntervalMax = Interval Max`
    /// - `connSupervisionTimeout = Timeout`
    /// - `maxConnLatency = min(500, ((connSupervisionTimeout / (2 * connIntervalMax)) - 1))`
    ///
    /// See the Bluetooth specification, Vol 3, Part A, Section 4.20. Versions 4.1, 4.2 and 5.0.
    ///
    /// Inclues the provided value and maximum allowed value, respectively.
    BadL2CapConnectionUpdateRequestLatency(u16, u16),

    /// For the [L2CAP Connection Update Request](VendorEvent::L2CapConnectionUpdateRequest) event:
    /// The provided timeout is invalid. The timeout field shall have a value in the range of 100 ms
    /// to 32 seconds (inclusive).
    ///
    /// See the Bluetooth specification, Vol 3, Part A, Section 4.20. Versions 4.1, 4.2 and 5.0.
    ///
    /// Inclues the provided value.
    BadL2CapConnectionUpdateRequestTimeout(Duration),

    /// For the [ATT Find Information Response](VendorEvent::AttFindInformationResponse) event: The
    /// format code is invalid. Includes the unrecognized byte.
    BadAttFindInformationResponseFormat(u8),

    /// For the [ATT Find Information Response](VendorEvent::AttFindInformationResponse) event: The
    /// format code indicated 16-bit UUIDs, but the packet ends with a partial pair.
    AttFindInformationResponsePartialPair16,

    /// For the [ATT Find Information Response](VendorEvent::AttFindInformationResponse) event: The
    /// format code indicated 128-bit UUIDs, but the packet ends with a partial pair.
    AttFindInformationResponsePartialPair128,

    /// For the [ATT Find by Type Value Response](VendorEvent::AttFindByTypeValueResponse) event:
    /// The packet ends with a partial attribute pair.
    AttFindByTypeValuePartial,

    /// For the [ATT Read by Type Response](VendorEvent::AttReadByTypeResponse) event: The packet
    /// ends with a partial attribute handle-value pair.
    AttReadByTypeResponsePartial,

    /// For the [ATT Read by Group Type Response](VendorEvent::AttReadByGroupTypeResponse) event:
    /// The packet ends with a partial attribute data group.
    AttReadByGroupTypeResponsePartial,

    /// For the [GATT Procedure Complete](VendorEvent::GattProcedureComplete) event: The status
    /// code was not recognized. Includes the unrecognized byte.
    BadGattProcedureStatus(u8),

    /// For the [ATT Error Response](VendorEvent::AttErrorResponse) event: The request opcode was
    /// not recognized. Includes the unrecognized byte.
    BadAttRequestOpcode(u8),

    /// For the [ATT Error Response](VendorEvent::AttErrorResponse) event: The error code was not
    /// recognized. Includes the unrecognized byte.
    BadAttError(u8),

    /// For the [ATT Read Multiple Permit Request](VendorEvent::AttReadMultiplePermitRequest)
    /// event: The packet ends with a partial attribute handle.
    AttReadMultiplePermitRequestPartial,

    /// For the [HAL Read Config Data](crate::vendor::command::hal::HalCommands::read_config_data) command complete
    /// [event](crate::vendor::event::command::VendorReturnParameters::HalReadConfigData): The returned value has a length that
    /// does not correspond to a requested parameter. Known lengths are 1, 2, 6, or 16. Includes the
    /// number of bytes returned.
    BadConfigParameterLength(usize),

    /// For the [HAL Get Link Status](crate::vendor::command::hal::HalCommands::get_link_status) command complete
    /// [event](crate::vendor::event::command::VendorReturnParameters::HalGetLinkStatus): One of the bytes representing a link
    /// state does not represent a known link state. Returns the unknown value.
    UnknownLinkState(u8),

    /// For the [GAP Get Security Level](crate::vendor::command::gap::GapCommands::get_security_level) command complete
    /// [event](crate::vendor::event::command::VendorReturnParameters::GapGetSecurityLevel): One of the boolean values
    /// ([`mitm_protection_required`](command::GapSecurityLevel::mitm_protection_required),
    /// [`bonding_required`](command::GapSecurityLevel::bonding_required), or
    /// [`out_of_band_data_present`](command::GapSecurityLevel::out_of_band_data_present)) was
    /// neither 0 nor 1. The unknown value is provided.
    BadBooleanValue(u8),

    /// For the [GAP Get Security Level](crate::vendor::command::gap::GapCommands::get_security_level) command complete
    /// [event](crate::vendor::event::command::VendorReturnParameters::GapGetSecurityLevel): the pass key requirement field was
    /// an invalid value. The unknown byte is provided.
    BadPassKeyRequirement(u8),

    /// For the [GAP Get Bonded Devices](crate::vendor::command::gap::GapCommands::get_bonded_devices) command complete
    /// [event](crate::vendor::event::command::VendorReturnParameters::GapGetBondedDevices): the packat was not long enough to
    /// contain the number of addresses it claimed to contain.
    PartialBondedDeviceAddress,

    /// For the [GAP Get Bonded Devices](crate::vendor::command::gap::GapCommands::get_bonded_devices) command complete
    /// [event](crate::vendor::event::command::VendorReturnParameters::GapGetBondedDevices): one of the address type bytes was
    /// invalid. Includes the invalid byte.
    BadBdAddrType(u8),

    /// For the [GATT EAT Bearer](crate::vendor::event::VendorEvent::GattEattBrearer) event: The EAB state was not recognized.
    BadEabState(u8),

    /// For the [HAL End Of Radio Activity](VendorEvent::HalEndOfRadioActivity) event: The Radio Event code was not recognized.
    BadRadioEvent(u8),

    /// For the [HAL Firmware Error](VendorEvent::HalFirmareError) event: The Radio Event code was not recognized.
    BadFirmwareError(u8),
}

macro_rules! require_len {
    ($left:expr, $right:expr) => {
        if $left.len() != $right {
            return Err(crate::event::Error::BadLength($left.len(), $right));
        }
    };
}

macro_rules! require_len_at_least {
    ($left:expr, $right:expr) => {
        if $left.len() < $right {
            return Err(crate::event::Error::BadLength($left.len(), $right));
        }
    };
}

fn first_16<T>(buffer: &[T]) -> &[T] {
    if buffer.len() < 16 {
        buffer
    } else {
        &buffer[..16]
    }
}

impl VendorEvent {
    pub fn new(buffer: &[u8]) -> Result<Self, crate::event::Error> {
        require_len_at_least!(buffer, 2);

        let event_code = LittleEndian::read_u16(&buffer[0..=1]);

        match event_code {
            // SHCI "C2 Ready" event
            0x9200 => Ok(VendorEvent::CoprocessorReady(to_coprocessor_ready(buffer)?)),

            0x0004 => Ok(VendorEvent::HalEndOfRadioActivity(
                to_hal_end_of_radio_activity(buffer)?,
            )),
            0x0005 => Ok(VendorEvent::HalScanReqReport(to_hal_scan_req_report(
                buffer,
            )?)),
            0x0006 => Ok(VendorEvent::HalFirmwareError(to_hal_firmware_error(
                buffer,
            )?)),
            0x0400 => Ok(VendorEvent::GapLimitedDiscoverableTimeout),
            0x0401 => Ok(VendorEvent::GapPairingComplete(to_gap_pairing_complete(
                buffer,
            )?)),
            0x0402 => Ok(VendorEvent::GapPassKeyRequest(to_conn_handle(buffer)?)),
            0x0403 => Ok(VendorEvent::GapAuthorizationRequest(to_conn_handle(
                buffer,
            )?)),
            0x0404 => Ok(VendorEvent::GapPeripheralSecurityInitiated),
            0x0405 => Ok(VendorEvent::GapBondLost),
            0x0406 => Ok(VendorEvent::GapDeviceFound(to_gap_device_found(buffer)?)),
            0x0407 => Ok(VendorEvent::GapProcedureComplete(
                to_gap_procedure_complete(buffer)?,
            )),
            0x0408 => Ok(VendorEvent::GapAddressNotResolved(to_conn_handle(buffer)?)),
            0x0409 => Ok(VendorEvent::GapNumericComparisonValue(
                to_numeric_comparison_value(buffer)?,
            )),
            0x040A => Ok(VendorEvent::GapKeypressNotification(
                to_keypress_notification(buffer)?,
            )),
            0x0800 => Ok(VendorEvent::L2CapConnectionUpdateResponse(
                to_l2cap_connection_update_response(buffer)?,
            )),
            0x0801 => Ok(VendorEvent::L2CapProcedureTimeout(
                to_l2cap_procedure_timeout(buffer)?,
            )),
            0x0802 => Ok(VendorEvent::L2CapConnectionUpdateRequest(
                to_l2cap_connection_update_request(buffer)?,
            )),
            0x080A => Ok(VendorEvent::L2CapCommandReject(to_l2cap_command_reject(
                buffer,
            )?)),
            0x0810 => Ok(VendorEvent::L2CapCocConnect(to_l2cap_coc_connect(buffer)?)),
            0x0811 => Ok(VendorEvent::L2CapCocConnectConfirm(
                to_l2cap_coc_connect_confirm(buffer)?,
            )),
            0x0812 => Ok(VendorEvent::L2CapCocReconfig(to_l2cap_coc_reconfig(
                buffer,
            )?)),
            0x0813 => Ok(VendorEvent::L2CapCocReconfigConfirm(
                to_l2cap_coc_reconfig_confirm(buffer)?,
            )),
            0x0814 => Ok(VendorEvent::L2CapCocDisconnect(buffer[0])),
            0x0815 => Ok(VendorEvent::L2CapCocFlowControl(to_l2cap_coc_flow_control(
                buffer,
            )?)),
            0x0816 => Ok(VendorEvent::L2CapCocRxData(to_l2cap_coc_rx_data(buffer)?)),
            0x0817 => Ok(VendorEvent::L2CapCocTxPoolAvailable),
            0x0C01 => Ok(VendorEvent::GattAttributeModified(
                to_gatt_attribute_modified(buffer)?,
            )),
            0x0C02 => Ok(VendorEvent::GattProcedureTimeout(to_conn_handle(buffer)?)),
            0x0C03 => Ok(VendorEvent::AttExchangeMtuResponse(
                to_att_exchange_mtu_resp(buffer)?,
            )),
            0x0C04 => Ok(VendorEvent::AttFindInformationResponse(
                to_att_find_information_response(buffer)?,
            )),
            0x0C05 => Ok(VendorEvent::AttFindByTypeValueResponse(
                to_att_find_by_value_type_response(buffer)?,
            )),
            0x0C06 => Ok(VendorEvent::AttReadByTypeResponse(
                to_att_read_by_type_response(buffer)?,
            )),
            0x0C07 => Ok(VendorEvent::AttReadResponse(to_att_read_response(buffer)?)),
            0x0C08 => Ok(VendorEvent::AttReadBlobResponse(to_att_read_response(
                buffer,
            )?)),
            0x0C09 => Ok(VendorEvent::AttReadMultipleResponse(to_att_read_response(
                buffer,
            )?)),
            0x0C0A => Ok(VendorEvent::AttReadByGroupTypeResponse(
                to_att_read_by_group_type_response(buffer)?,
            )),
            0x0C0C => Ok(VendorEvent::AttPrepareWriteResponse(
                to_att_prepare_write_response(buffer)?,
            )),
            0x0C0D => Ok(VendorEvent::AttExecuteWriteResponse(to_conn_handle(
                buffer,
            )?)),
            0x0C0E => Ok(VendorEvent::GattIndication(to_attribute_value(buffer)?)),
            0x0C0F => Ok(VendorEvent::GattNotification(to_attribute_value(buffer)?)),
            0x0C10 => Ok(VendorEvent::GattProcedureComplete(
                to_gatt_procedure_complete(buffer)?,
            )),
            0x0C11 => Ok(VendorEvent::AttErrorResponse(to_att_error_response(
                buffer,
            )?)),
            0x0C12 => Ok(VendorEvent::GattDiscoverOrReadCharacteristicByUuidResponse(
                to_attribute_value(buffer)?,
            )),
            0x0C13 => Ok(VendorEvent::AttWritePermitRequest(to_write_permit_request(
                buffer,
            )?)),
            0x0C14 => Ok(VendorEvent::AttReadPermitRequest(
                to_att_read_permit_request(buffer)?,
            )),
            0x0C15 => Ok(VendorEvent::AttReadMultiplePermitRequest(
                to_att_read_multiple_permit_request(buffer)?,
            )),
            0x0C16 => Ok(VendorEvent::GattTxPoolAvailable(to_gatt_tx_pool_available(
                buffer,
            )?)),
            0x0C17 => Ok(VendorEvent::GattServerConfirmation(to_conn_handle(buffer)?)),
            0x0C18 => Ok(VendorEvent::AttPrepareWritePermitRequest(
                to_att_prepare_write_permit_request(buffer)?,
            )),
            0x0C19 => Ok(VendorEvent::GattEattBrearer(to_gatt_eatt_bearer(buffer)?)),
            0x0C1A => Ok(VendorEvent::GattMultiNotification(
                to_gatt_multi_notification(buffer)?,
            )),
            0x0C1B => Ok(VendorEvent::GattNotificationComplete({
                require_len!(buffer, 4);
                AttributeHandle(LittleEndian::read_u16(&buffer[2..]))
            })),
            0x0C1D => Ok(VendorEvent::GattReadExt(to_gatt_read_ext(buffer)?)),
            0x0C1E => Ok(VendorEvent::GattIndicationExt(to_attribute_value_ext(
                buffer,
            )?)),
            0x0C1F => Ok(VendorEvent::GattNotificationExt(to_attribute_value_ext(
                buffer,
            )?)),
            _ => Err(crate::event::Error::Vendor(VendorError::UnknownEvent(
                event_code,
            ))),
        }
    }
}

/// Potential firmware kinds for [`CoprocessorReady`](VendorEvent::CoprocessorReady)
/// event.
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum FirmwareKind {
    /// Wireless firmware (BLE, Thread, etc.)
    Wireless,

    /// RCC firmware.
    Rcc,
}

impl TryFrom<u8> for FirmwareKind {
    type Error = VendorError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(FirmwareKind::Wireless),
            1 => Ok(FirmwareKind::Rcc),
            _ => Err(VendorError::UnknownFirmwareKind(value)),
        }
    }
}

/// Convert a buffer to the `CoprocessorReady` `VendorEvent`.
///
/// # Errors
///
/// - Returns a `BadLength` HCI error if the buffer is not exactly 3 bytes long
/// - Returns a `UnknownFirmwareKind` CPU2 error if the firmware kind is not recognized.
fn to_coprocessor_ready(buffer: &[u8]) -> Result<FirmwareKind, crate::event::Error> {
    require_len!(buffer, 3);

    buffer[0].try_into().map_err(crate::event::Error::Vendor)
}

macro_rules! require_l2cap_event_data_len {
    ($left:expr, $right:expr) => {
        let actual = $left[4];
        if actual != $right {
            return Err(crate::event::Error::Vendor(
                VendorError::BadL2CapDataLength(actual, $right),
            ));
        }
    };
}

macro_rules! require_l2cap_len {
    ($actual:expr, $expected:expr) => {
        if $actual != $expected {
            return Err(crate::event::Error::Vendor(VendorError::BadL2CapLength(
                $actual, $expected,
            )));
        }
    };
}

/// This event is generated when the central device responds to the L2CAP connection update request
/// packet.
///
/// For more info see connection parameter update response and command reject in Bluetooth Core v4.0
/// spec.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct L2CapConnectionUpdateResponse {
    /// The connection handle related to the event
    pub conn_handle: ConnectionHandle,

    /// The result of the update request, including details about the result.
    pub result: L2CapConnectionUpdateResult,
}

/// Reasons why an L2CAP command was rejected. see the Bluetooth specification, v4.1, Vol 3, Part A,
/// Section 4.1.
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum L2CapRejectionReason {
    /// The controller sent an unknown command.
    CommandNotUnderstood,
    /// When multiple commands are included in an L2CAP packet and the packet exceeds the signaling
    /// MTU (MTUsig) of the receiver, a single Command Reject packet shall be sent in response.
    SignalingMtuExceeded,
    /// Invalid CID in request
    InvalidCid,
}

impl TryFrom<u16> for L2CapRejectionReason {
    type Error = VendorError;

    fn try_from(value: u16) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(L2CapRejectionReason::CommandNotUnderstood),
            1 => Ok(L2CapRejectionReason::SignalingMtuExceeded),
            2 => Ok(L2CapRejectionReason::InvalidCid),
            _ => Err(VendorError::BadL2CapRejectionReason(value)),
        }
    }
}

/// Potential results that can be used in the L2CAP connection update response.
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum L2CapConnectionUpdateResult {
    /// The update request was rejected. The code indicates the reason for the rejection.
    CommandRejected(L2CapRejectionReason),

    /// The L2CAP connection update response is valid. The code indicates if the parameters were
    /// rejected.
    ParametersRejected,

    /// The L2CAP connection update response is valid. The code indicates if the parameters were
    /// updated.
    ParametersUpdated,
}

fn to_l2cap_connection_update_accepted_result(
    value: u16,
) -> Result<L2CapConnectionUpdateResult, VendorError> {
    match value {
        0x0000 => Ok(L2CapConnectionUpdateResult::ParametersUpdated),
        0x0001 => Ok(L2CapConnectionUpdateResult::ParametersRejected),
        _ => Err(VendorError::BadL2CapConnectionResponseResult(value)),
    }
}

fn extract_l2cap_connection_update_response_result(
    buffer: &[u8],
) -> Result<L2CapConnectionUpdateResult, VendorError> {
    match buffer[5] {
        0x01 => Ok(L2CapConnectionUpdateResult::CommandRejected(
            LittleEndian::read_u16(&buffer[9..]).try_into()?,
        )),
        0x13 => to_l2cap_connection_update_accepted_result(LittleEndian::read_u16(&buffer[9..])),
        _ => Err(VendorError::BadL2CapConnectionResponseCode(buffer[5])),
    }
}

fn to_l2cap_connection_update_response(
    buffer: &[u8],
) -> Result<L2CapConnectionUpdateResponse, crate::event::Error> {
    require_len!(buffer, 6);

    Ok(L2CapConnectionUpdateResponse {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        result: to_l2cap_connection_update_accepted_result(LittleEndian::read_u16(&buffer[4..]))
            .map_err(crate::event::Error::Vendor)?,
    })
}

/// This event is generated when the central device does not respond to the connection update
/// request within 30 seconds.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct L2CapProcedureTimeout {
    /// The connection handle related to the event.
    pub conn_handle: ConnectionHandle,
}

fn to_l2cap_procedure_timeout(buffer: &[u8]) -> Result<ConnectionHandle, crate::event::Error> {
    require_len!(buffer, 5);
    require_l2cap_event_data_len!(buffer, 0);

    Ok(ConnectionHandle(LittleEndian::read_u16(&buffer[2..])))
}

/// The event is given by the L2CAP layer when a connection update request is received from the
/// peripheral.
///
/// The application has to respond by calling
/// [`l2cap_connection_parameter_update_response`](crate::vendor::command::l2cap::L2capCommands::connection_parameter_update_response).
///
/// Defined in Vol 3, Part A, section 4.20 of the Bluetooth specification.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct L2CapConnectionUpdateRequest {
    /// Handle of the connection for which the connection update request has been received.  The
    /// [same handle](crate::vendor::command::l2cap::ConnectionParameterUpdateResponse::conn_handle) has to be
    /// returned while responding to the event with the command
    /// [`l2cap_connection_parameter_update_response`](crate::vendor::command::l2cap::L2capCommands::connection_parameter_update_response).
    pub conn_handle: ConnectionHandle,

    /// This is the identifier which associates the request to the response. The
    /// [same identifier](crate::vendor::command::l2cap::ConnectionParameterUpdateResponse::identifier) has to be returned
    /// by the upper layer in the command
    /// [`l2cap_connection_parameter_update_response`](crate::vendor::command::l2cap::L2capCommands::connection_parameter_update_response).
    pub identifier: u8,

    /// Defines the range of the connection interval, the latency, and the supervision timeout.
    pub conn_interval: ConnectionInterval,
}

fn to_l2cap_connection_update_request(
    buffer: &[u8],
) -> Result<L2CapConnectionUpdateRequest, crate::event::Error> {
    require_len!(buffer, 16);
    require_l2cap_event_data_len!(buffer, 11);
    require_l2cap_len!(LittleEndian::read_u16(&buffer[6..]), 8);

    let interval = ConnectionInterval::from_bytes(&buffer[8..16])
        .map_err(VendorError::BadConnectionInterval)
        .map_err(crate::event::Error::Vendor)?;

    Ok(L2CapConnectionUpdateRequest {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        identifier: buffer[5],
        conn_interval: interval,
    })
}

/// This event is generated when the pairing process has completed successfully or a pairing
/// procedure timeout has occurred or the pairing has failed. This is to notify the application that
/// we have paired with a remote device so that it can take further actions or to notify that a
/// timeout has occurred so that the upper layer can decide to disconnect the link.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct GapPairingComplete {
    /// Connection handle on which the pairing procedure completed
    pub conn_handle: ConnectionHandle,

    /// Reason the pairing is complete.
    pub status: GapPairingStatus,

    /// Pairing failed reason code (valid in case of pairing failed status)
    pub reason: Option<GapPairingReason>,
}

/// Reasons the [GAP Pairing Complete](VendorEvent::GapPairingComplete) event was generated.
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum GapPairingStatus {
    /// Pairing with a remote device was successful.
    Success,
    /// The SMP timeout has elapsed and no further SMP commands will be processed until
    /// reconnection.
    Timeout,
    /// The pairing failed with the remote device.
    Failed,
}

impl TryFrom<u8> for GapPairingStatus {
    type Error = VendorError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(GapPairingStatus::Success),
            1 => Ok(GapPairingStatus::Timeout),
            2 => Ok(GapPairingStatus::Failed),
            _ => Err(VendorError::BadGapPairingStatus(value)),
        }
    }
}

/// Reasons the [GAP Pairing Complete](VendorEvent::GapPairingComplete) event failed.
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum GapPairingReason {
    PasskeyEntryFailed = 0x01,
    OobNotAvailable = 0x02,
    AuthRequirements = 0x03,
    ConfirmValueFailed = 0x04,
    PairingNotSupported = 0x05,
    EncryptionKeySize = 0x06,
    CommandNotSupported = 0x07,
    Unspecified = 0x08,
    RepeatedAttemptes = 0x09,
    InvalidParams = 0x0A,
    DHKeyCheckFailed = 0x0B,
    NumericComparisonFailed = 0x0C,
    KeyRejected = 0x0F,
}

impl TryFrom<u8> for GapPairingReason {
    type Error = VendorError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x01 => Ok(GapPairingReason::PasskeyEntryFailed),
            0x02 => Ok(GapPairingReason::OobNotAvailable),
            0x03 => Ok(GapPairingReason::AuthRequirements),
            0x04 => Ok(GapPairingReason::ConfirmValueFailed),
            0x05 => Ok(GapPairingReason::PairingNotSupported),
            0x06 => Ok(GapPairingReason::EncryptionKeySize),
            0x07 => Ok(GapPairingReason::CommandNotSupported),
            0x08 => Ok(GapPairingReason::Unspecified),
            0x09 => Ok(GapPairingReason::RepeatedAttemptes),
            0x0A => Ok(GapPairingReason::InvalidParams),
            0x0B => Ok(GapPairingReason::DHKeyCheckFailed),
            0x0C => Ok(GapPairingReason::NumericComparisonFailed),
            0x0F => Ok(GapPairingReason::KeyRejected),
            _ => Err(VendorError::BadGapPairingErrorReason(value)),
        }
    }
}

fn to_gap_pairing_complete(buffer: &[u8]) -> Result<GapPairingComplete, crate::event::Error> {
    require_len!(buffer, 6);

    let status: GapPairingStatus = buffer[4].try_into().map_err(crate::event::Error::Vendor)?;
    let reason = match status {
        GapPairingStatus::Success => None,
        _ => Some(buffer[5].try_into().map_err(crate::event::Error::Vendor)?),
    };

    Ok(GapPairingComplete {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        status,
        reason,
    })
}

fn to_conn_handle(buffer: &[u8]) -> Result<ConnectionHandle, crate::event::Error> {
    require_len_at_least!(buffer, 4);
    Ok(ConnectionHandle(LittleEndian::read_u16(&buffer[2..])))
}

/// The event is given by the GAP layer to the upper layers when a device is discovered during
/// scanning as a consequence of one of the GAP procedures started by the upper layers.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct GapDeviceFound {
    /// Type of event
    pub event: GapDeviceFoundEvent,

    /// Address of the peer device found during scanning
    pub bdaddr: BdAddrType,

    // Length of significant data
    data_len: usize,

    // Advertising or scan response data.
    data_buf: [u8; 31],

    /// Received signal strength indicator (range: -127 - 20).
    pub rssi: Option<i8>,
}

impl GapDeviceFound {
    /// Returns the valid scan response data.
    pub fn data(&self) -> &[u8] {
        &self.data_buf[..self.data_len]
    }
}

pub use crate::event::AdvertisementEvent as GapDeviceFoundEvent;

use super::command::gap::EventFlags;

fn to_gap_device_found(buffer: &[u8]) -> Result<GapDeviceFound, crate::event::Error> {
    const RSSI_UNAVAILABLE: i8 = 127;

    require_len_at_least!(buffer, 12);

    let data_len = buffer[10] as usize;
    require_len!(buffer, 12 + data_len);

    let rssi = unsafe { mem::transmute::<u8, i8>(buffer[buffer.len() - 1]) };

    let mut addr = BdAddr([0; 6]);
    addr.0.copy_from_slice(&buffer[4..10]);
    let mut event = GapDeviceFound {
        event: buffer[2].try_into().map_err(|e| {
            if let crate::event::Error::BadLeAdvertisementType(code) = e {
                crate::event::Error::Vendor(VendorError::BadGapDeviceFoundEvent(code))
            } else {
                unreachable!()
            }
        })?,
        bdaddr: crate::to_bd_addr_type(buffer[3], addr)
            .map_err(|e| crate::event::Error::Vendor(VendorError::BadGapBdAddrType(e.0)))?,
        data_len,
        data_buf: [0; 31],
        rssi: if rssi == RSSI_UNAVAILABLE {
            None
        } else {
            Some(rssi)
        },
    };
    event.data_buf[..event.data_len].copy_from_slice(&buffer[11..buffer.len() - 1]);

    Ok(event)
}

/// This event is sent by the GAP to the upper layers when a procedure previously started has been
/// terminated by the upper layer or has completed for any other reason
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct GapProcedureComplete {
    /// Type of procedure that completed
    pub procedure: GapProcedure,
    /// Status of the procedure
    pub status: GapProcedureStatus,
}

/// Maximum length of the name returned in the [`NameDiscovery`](GapProcedure::NameDiscovery)
/// procedure.
pub const MAX_NAME_LEN: usize = 248;

/// Newtype for the name buffer returned after successful
/// [`NameDiscovery`](GapProcedure::NameDiscovery).
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct NameBuffer(pub [u8; MAX_NAME_LEN]);

impl Debug for NameBuffer {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        first_16(&self.0).fmt(f)
    }
}

impl PartialEq<NameBuffer> for NameBuffer {
    fn eq(&self, other: &Self) -> bool {
        if self.0.len() != other.0.len() {
            return false;
        }

        for (a, b) in self.0.iter().zip(other.0.iter()) {
            if a != b {
                return false;
            }
        }

        true
    }
}

/// Procedures whose completion may be reported by
/// [`GapProcedureComplete`](VendorEvent::GapProcedureComplete).
#[allow(clippy::large_enum_variant)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum GapProcedure {
    /// See Vol 3, Part C, section 9.2.5.
    LimitedDiscovery,
    /// See Vol 3, Part C, section 9.2.6.
    GeneralDiscovery,
    /// See Vol 3, Part C, section 9.2.7. Contains the number of valid bytes and buffer with enough
    /// space for the maximum length of the name that can be retuned.
    NameDiscovery(usize, NameBuffer),
    /// See Vol 3, Part C, section 9.3.5.
    AutoConnectionEstablishment,
    /// See Vol 3, Part C, section 9.3.6. Contains the reconnection address.
    GeneralConnectionEstablishment,
    /// See Vol 3, Part C, section 9.3.7.
    SelectiveConnectionEstablishment,
    /// See Vol 3, Part C, section 9.3.8.
    DirectConnectionEstablishment,
    Observation,
}

/// Possible results of a [GAP procedure](VendorEvent::GapProcedureComplete).
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum GapProcedureStatus {
    /// BLE Status Success.
    Success,
    /// BLE Status Failed.
    Failed,
    /// Procedure failed due to authentication requirements.
    AuthFailure,
}

impl TryFrom<u8> for GapProcedureStatus {
    type Error = VendorError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x00 => Ok(GapProcedureStatus::Success),
            0x41 => Ok(GapProcedureStatus::Failed),
            0x05 => Ok(GapProcedureStatus::AuthFailure),
            _ => Err(VendorError::BadGapProcedureStatus(value)),
        }
    }
}

fn to_gap_procedure_complete(buffer: &[u8]) -> Result<GapProcedureComplete, crate::event::Error> {
    require_len_at_least!(buffer, 4);

    let procedure = match buffer[2] {
        0x01 => GapProcedure::LimitedDiscovery,
        0x02 => GapProcedure::GeneralDiscovery,
        0x04 => {
            require_len_at_least!(buffer, 5);
            let name_len = buffer.len() - 4;
            let mut name = NameBuffer([0; MAX_NAME_LEN]);
            name.0[..name_len].copy_from_slice(&buffer[4..]);

            GapProcedure::NameDiscovery(name_len, name)
        }
        0x08 => GapProcedure::AutoConnectionEstablishment,
        0x10 => GapProcedure::GeneralConnectionEstablishment,
        0x20 => GapProcedure::SelectiveConnectionEstablishment,
        0x40 => GapProcedure::DirectConnectionEstablishment,
        0x80 => GapProcedure::Observation,
        _ => {
            return Err(crate::event::Error::Vendor(VendorError::BadGapProcedure(
                buffer[2],
            )));
        }
    };

    Ok(GapProcedureComplete {
        procedure,
        status: buffer[3].try_into().map_err(crate::event::Error::Vendor)?,
    })
}

/// This event is generated to the application by the ATT server when a client modifies any
/// attribute on the server, as consequence of one of the following ATT procedures:
/// - write without response
/// - signed write without response
/// - write characteristic value
/// - write long characteristic value
/// - reliable write
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct GattAttributeModified {
    /// The connection handle which modified the attribute
    pub conn_handle: ConnectionHandle,
    ///  Handle of the attribute that was modified
    pub attr_handle: AttributeHandle,

    offset: u16,

    /// Number of valid bytes in |data|.
    data_len: usize,
    /// The new attribute value, starting from the given offset. If compiling with "ms" support, the
    /// offset is 0.
    data_buf: [u8; MAX_ATTRIBUTE_LEN],
}

impl GattAttributeModified {
    /// Returns the valid attribute data returned by the ATT attribute modified event as a slice of
    /// bytes.
    pub fn data(&self) -> &[u8] {
        &self.data_buf[..self.data_len]
    }
}

/// Newtype for an attribute handle. These handles are IDs, not general integers, and should not be
/// manipulated as such.
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttributeHandle(pub u16);

// Defines the maximum length of a ATT attribute value field. This is determined by the max packet
// size (255) less the minimum number of bytes used by other fields in any packet.
const MAX_ATTRIBUTE_LEN: usize = 248;

impl Debug for GattAttributeModified {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        f.debug_struct("GattAttributeModified")
            .field("conn_handle", &self.conn_handle)
            .field("attr_handle", &self.attr_handle)
            .field("offset", &self.offset)
            .field("data", &first_16(self.data()))
            .finish()
    }
}

fn to_gatt_attribute_modified(buffer: &[u8]) -> Result<GattAttributeModified, crate::event::Error> {
    require_len_at_least!(buffer, 10);

    let data_len = LittleEndian::read_u16(&buffer[8..]) as usize;
    require_len!(buffer, 10 + data_len);

    let mut data = [0; MAX_ATTRIBUTE_LEN];
    data[..data_len].copy_from_slice(&buffer[10..]);

    let offset_field = LittleEndian::read_u16(&buffer[6..]);
    Ok(GattAttributeModified {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        attr_handle: AttributeHandle(LittleEndian::read_u16(&buffer[4..])),
        offset: (offset_field & 0x7FFF),
        data_len,
        data_buf: data,
    })
}

/// This event is generated in response to an Exchange MTU request.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttExchangeMtuResponse {
    ///  The connection handle related to the response.
    pub conn_handle: ConnectionHandle,

    /// Attribute server receive MTU size.
    pub server_rx_mtu: usize,
}

fn to_att_exchange_mtu_resp(buffer: &[u8]) -> Result<AttExchangeMtuResponse, crate::event::Error> {
    require_len!(buffer, 6);
    Ok(AttExchangeMtuResponse {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        server_rx_mtu: LittleEndian::read_u16(&buffer[4..]) as usize,
    })
}

/// This event is generated in response to a Find Information Request. See Find Information Response
/// in Bluetooth Core v4.0 spec.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttFindInformationResponse {
    /// The connection handle related to the response
    pub conn_handle: ConnectionHandle,
    /// The Find Information Response shall have complete handle-UUID pairs. Such pairs shall not be
    /// split across response packets; this also implies that a handleUUID pair shall fit into a
    /// single response packet. The handle-UUID pairs shall be returned in ascending order of
    /// attribute handles.
    handle_uuid_pairs: HandleUuidPairs,
}

impl AttFindInformationResponse {
    /// The Find Information Response shall have complete handle-UUID pairs. Such pairs shall not be
    /// split across response packets; this also implies that a handleUUID pair shall fit into a
    /// single response packet. The handle-UUID pairs shall be returned in ascending order of
    /// attribute handles.
    pub fn handle_uuid_pair_iter(&self) -> HandleUuidPairIterator {
        match self.handle_uuid_pairs {
            HandleUuidPairs::Format16(count, ref data) => {
                HandleUuidPairIterator::Format16(HandleUuid16PairIterator {
                    data,
                    count,
                    next_index: 0,
                })
            }
            HandleUuidPairs::Format128(count, ref data) => {
                HandleUuidPairIterator::Format128(HandleUuid128PairIterator {
                    data,
                    count,
                    next_index: 0,
                })
            }
        }
    }
}

// Assuming a maximum HCI packet size of 255, these are the maximum number of handle-UUID pairs for
// each format that can be in one packet.  Formats cannot be mixed in a single packet.
//
// Packets have 6 other bytes of data preceding the handle-UUID pairs.
//
// max = floor((255 - 6) / pair_length)
const MAX_FORMAT16_PAIR_COUNT: usize = 62;
const MAX_FORMAT128_PAIR_COUNT: usize = 13;

/// One format of the handle-UUID pairs in the [`AttFindInformationResponse`] event. The UUIDs are
/// 16 bits.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct HandleUuid16Pair {
    /// Attribute handle
    pub handle: AttributeHandle,
    /// Attribute UUID
    pub uuid: Uuid16,
}

/// One format of the handle-UUID pairs in the [`AttFindInformationResponse`] event. The UUIDs are
/// 128 bits.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct HandleUuid128Pair {
    /// Attribute handle
    pub handle: AttributeHandle,
    /// Attribute UUID
    pub uuid: Uuid128,
}

/// Newtype for the 16-bit UUID buffer.
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct Uuid16(pub u16);

/// Newtype for the 128-bit UUID buffer.
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct Uuid128(pub [u8; 16]);

#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
enum HandleUuidPairs {
    Format16(usize, [HandleUuid16Pair; MAX_FORMAT16_PAIR_COUNT]),
    Format128(usize, [HandleUuid128Pair; MAX_FORMAT128_PAIR_COUNT]),
}

impl Debug for HandleUuidPairs {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(f, "{{")?;
        match *self {
            HandleUuidPairs::Format16(count, pairs) => {
                for handle_uuid_pair in &pairs[..count] {
                    write!(
                        f,
                        "{{{:?}, {:?}}}",
                        handle_uuid_pair.handle, handle_uuid_pair.uuid
                    )?
                }
            }
            HandleUuidPairs::Format128(count, pairs) => {
                for handle_uuid_pair in &pairs[..count] {
                    write!(
                        f,
                        "{{{:?}, {:?}}}",
                        handle_uuid_pair.handle, handle_uuid_pair.uuid
                    )?
                }
            }
        }
        write!(f, "}}")
    }
}

/// Possible iterators over handle-UUID pairs that can be returnedby the
/// [ATT find information response](AttFindInformationResponse). All pairs from the same event have the same format.
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum HandleUuidPairIterator<'a> {
    /// The event contains 16-bit UUIDs.
    Format16(HandleUuid16PairIterator<'a>),
    /// The event contains 128-bit UUIDs.
    Format128(HandleUuid128PairIterator<'a>),
}

/// Iterator over handle-UUID pairs for 16-bit UUIDs.
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct HandleUuid16PairIterator<'a> {
    data: &'a [HandleUuid16Pair; MAX_FORMAT16_PAIR_COUNT],
    count: usize,
    next_index: usize,
}

impl<'a> Iterator for HandleUuid16PairIterator<'a> {
    type Item = HandleUuid16Pair;
    fn next(&mut self) -> Option<Self::Item> {
        if self.next_index >= self.count {
            return None;
        }

        let index = self.next_index;
        self.next_index += 1;
        Some(self.data[index])
    }
}

/// Iterator over handle-UUID pairs for 128-bit UUIDs.
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct HandleUuid128PairIterator<'a> {
    data: &'a [HandleUuid128Pair; MAX_FORMAT128_PAIR_COUNT],
    count: usize,
    next_index: usize,
}

impl<'a> Iterator for HandleUuid128PairIterator<'a> {
    type Item = HandleUuid128Pair;
    fn next(&mut self) -> Option<Self::Item> {
        if self.next_index >= self.count {
            return None;
        }

        let index = self.next_index;
        self.next_index += 1;
        Some(self.data[index])
    }
}

fn to_att_find_information_response(
    buffer: &[u8],
) -> Result<AttFindInformationResponse, crate::event::Error> {
    require_len_at_least!(buffer, 4);

    let data_len = buffer[5] as usize;
    require_len!(buffer, 6 + data_len);

    Ok(AttFindInformationResponse {
        conn_handle: to_conn_handle(buffer)?,
        handle_uuid_pairs: match buffer[4] {
            1 => to_handle_uuid16_pairs(&buffer[6..]).map_err(crate::event::Error::Vendor)?,
            2 => to_handle_uuid128_pairs(&buffer[6..]).map_err(crate::event::Error::Vendor)?,
            _ => {
                return Err(crate::event::Error::Vendor(
                    VendorError::BadAttFindInformationResponseFormat(buffer[4]),
                ));
            }
        },
    })
}

// [0x4, 0xc, 0x1, 0x8, 0x1, 0x8, 0x12, 0x0, 0x3, 0x5, 0x13, 0x0, 0x2, 0x29]

fn to_handle_uuid16_pairs(buffer: &[u8]) -> Result<HandleUuidPairs, VendorError> {
    const PAIR_LEN: usize = 4;
    if buffer.len() % PAIR_LEN != 0 {
        return Err(VendorError::AttFindInformationResponsePartialPair16);
    }

    let count = buffer.len() / PAIR_LEN;
    let mut pairs = [HandleUuid16Pair {
        handle: AttributeHandle(0),
        uuid: Uuid16(0),
    }; MAX_FORMAT16_PAIR_COUNT];
    for (i, pair) in pairs.iter_mut().enumerate().take(count) {
        let index = i * PAIR_LEN;
        pair.handle = AttributeHandle(LittleEndian::read_u16(&buffer[index..]));
        pair.uuid = Uuid16(LittleEndian::read_u16(&buffer[2 + index..]));
    }

    Ok(HandleUuidPairs::Format16(count, pairs))
}

fn to_handle_uuid128_pairs(buffer: &[u8]) -> Result<HandleUuidPairs, VendorError> {
    const PAIR_LEN: usize = 18;
    if buffer.len() % PAIR_LEN != 0 {
        return Err(VendorError::AttFindInformationResponsePartialPair128);
    }

    let count = buffer.len() / PAIR_LEN;
    let mut pairs = [HandleUuid128Pair {
        handle: AttributeHandle(0),
        uuid: Uuid128([0; 16]),
    }; MAX_FORMAT128_PAIR_COUNT];
    for (i, pair) in pairs.iter_mut().enumerate().take(count) {
        let index = i * PAIR_LEN;
        let next_index = (i + 1) * PAIR_LEN;
        pair.handle = AttributeHandle(LittleEndian::read_u16(&buffer[index..]));
        pair.uuid.0.copy_from_slice(&buffer[2 + index..next_index]);
    }

    Ok(HandleUuidPairs::Format128(count, pairs))
}

/// This event is generated in response to a Find By Type Value Request.
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttFindByTypeValueResponse {
    /// The connection handle related to the response.
    pub conn_handle: ConnectionHandle,

    /// The number of valid pairs that follow.
    handle_pair_count: usize,

    /// Handles Information List as defined in Bluetooth Core v4.1 spec.
    handles: [HandleInfoPair; MAX_HANDLE_INFO_PAIR_COUNT],
}

impl AttFindByTypeValueResponse {
    /// Returns an iterator over the Handles Information List as defined in Bluetooth Core v4.1
    /// spec.
    pub fn handle_pairs_iter(&self) -> HandleInfoPairIterator {
        HandleInfoPairIterator {
            event: self,
            next_index: 0,
        }
    }
}

impl Debug for AttFindByTypeValueResponse {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(f, "{{.conn_handle = {:?}, ", self.conn_handle)?;
        for handle_pair in self.handle_pairs_iter() {
            write!(f, "{:?}", handle_pair)?;
        }
        write!(f, "}}")
    }
}

// Assuming a maximum HCI packet size of 255, these are the maximum number of handle pairs that can
// be in one packet.
//
// Packets have 5 other bytes of data preceding the handle-UUID pairs.
//
// max = floor((255 - 5) / 4)
const MAX_HANDLE_INFO_PAIR_COUNT: usize = 62;

/// Simple container for the handle information returned in [`AttFindByTypeValueResponse`].
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct HandleInfoPair {
    /// Attribute handle
    pub attribute: AttributeHandle,
    /// Group End handle
    pub group_end: GroupEndHandle,
}

/// Newtype for Group End handles
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct GroupEndHandle(pub u16);

/// Iterator into valid [`HandleInfoPair`] structs returned in the
/// [ATT Find By Type Value Response](AttFindByTypeValueResponse) event.
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct HandleInfoPairIterator<'a> {
    event: &'a AttFindByTypeValueResponse,
    next_index: usize,
}

impl<'a> Iterator for HandleInfoPairIterator<'a> {
    type Item = HandleInfoPair;

    fn next(&mut self) -> Option<Self::Item> {
        if self.next_index >= self.event.handle_pair_count {
            return None;
        }

        let index = self.next_index;
        self.next_index += 1;
        Some(self.event.handles[index])
    }
}

fn to_att_find_by_value_type_response(
    buffer: &[u8],
) -> Result<AttFindByTypeValueResponse, crate::event::Error> {
    const PAIR_LEN: usize = 4;

    require_len_at_least!(buffer, 5);

    let data_len = buffer[4] as usize;
    require_len!(buffer, 5 + data_len);

    let pair_buffer = &buffer[5..];
    if pair_buffer.len() % PAIR_LEN != 0 {
        return Err(crate::event::Error::Vendor(
            VendorError::AttFindByTypeValuePartial,
        ));
    }

    let count = pair_buffer.len() / PAIR_LEN;
    let mut pairs = [HandleInfoPair {
        attribute: AttributeHandle(0),
        group_end: GroupEndHandle(0),
    }; MAX_HANDLE_INFO_PAIR_COUNT];
    for (i, pair) in pairs.iter_mut().enumerate().take(count) {
        let index = i * PAIR_LEN;
        pair.attribute = AttributeHandle(LittleEndian::read_u16(&pair_buffer[index..]));
        pair.group_end = GroupEndHandle(LittleEndian::read_u16(&pair_buffer[2 + index..]));
    }
    Ok(AttFindByTypeValueResponse {
        conn_handle: to_conn_handle(buffer)?,
        handle_pair_count: count,
        handles: pairs,
    })
}

/// This event is generated in response to a Read By Type Request.
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttReadByTypeResponse {
    /// The connection handle related to the response.
    pub conn_handle: ConnectionHandle,

    // Number of valid bytes in `handle_value_pair_buf`
    data_len: usize,
    // Length of each value in `handle_value_pair_buf`
    value_len: usize,
    // Raw data of the response. Contains 2 octets for the attribute handle followed by `value_len`
    // octets of value data. These pairs repeat for `data_len` bytes.
    handle_value_pair_buf: [u8; MAX_HANDLE_VALUE_PAIR_BUF_LEN],
}

// The maximum amount of data in the buffer is the max HCI packet size (255) less the other data in
// the packet.
const MAX_HANDLE_VALUE_PAIR_BUF_LEN: usize = 249;

impl Debug for AttReadByTypeResponse {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(f, "{{.conn_handle = {:?}, ", self.conn_handle)?;
        for handle_value_pair in self.handle_value_pair_iter() {
            write!(
                f,
                "{{handle: {:?}, value: {:?}}}",
                handle_value_pair.handle,
                first_16(handle_value_pair.value)
            )?;
        }
        write!(f, "}}")
    }
}

impl AttReadByTypeResponse {
    /// Return an iterator over all valid handle-value pairs returned with the response.
    pub fn handle_value_pair_iter(&self) -> HandleValuePairIterator {
        HandleValuePairIterator {
            event: self,
            index: 0,
        }
    }
}

/// Iterator over the valid handle-value pairs returned with the
/// [ATT Read by Type response](AttReadByTypeResponse).
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct HandleValuePairIterator<'a> {
    event: &'a AttReadByTypeResponse,
    index: usize,
}

impl<'a> Iterator for HandleValuePairIterator<'a> {
    type Item = HandleValuePair<'a>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.index >= self.event.data_len {
            return None;
        }

        let handle_index = self.index;
        let value_index = self.index + 2;
        self.index += 2 + self.event.value_len;
        let next_index = self.index;
        Some(HandleValuePair {
            handle: AttributeHandle(LittleEndian::read_u16(
                &self.event.handle_value_pair_buf[handle_index..],
            )),
            value: &self.event.handle_value_pair_buf[value_index..next_index],
        })
    }
}

/// A single handle-value pair returned by the [ATT Read by Type response](AttReadByTypeResponse).
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct HandleValuePair<'a> {
    /// Attribute handle
    pub handle: AttributeHandle,
    /// Attribute value. The caller must interpret the value correctly, depending on the expected
    /// type of the attribute.
    pub value: &'a [u8],
}

impl<'a> HandleValuePair<'a> {
    pub fn uuid(&self) -> u16 {
        LittleEndian::read_u16(&self.value[3..])
    }
}

fn to_att_read_by_type_response(
    buffer: &[u8],
) -> Result<AttReadByTypeResponse, crate::event::Error> {
    require_len_at_least!(buffer, 6);

    let data_len = buffer[5] as usize;
    require_len!(buffer, 6 + data_len);

    let handle_value_pair_len = buffer[4] as usize;
    let handle_value_pair_buf = &buffer[6..];
    if handle_value_pair_buf.len() % handle_value_pair_len != 0 {
        return Err(crate::event::Error::Vendor(
            VendorError::AttReadByTypeResponsePartial,
        ));
    }

    let mut full_handle_value_pair_buf = [0; MAX_HANDLE_VALUE_PAIR_BUF_LEN];
    full_handle_value_pair_buf[..handle_value_pair_buf.len()]
        .copy_from_slice(handle_value_pair_buf);

    Ok(AttReadByTypeResponse {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        data_len: handle_value_pair_buf.len(),
        value_len: handle_value_pair_len - 2,
        handle_value_pair_buf: full_handle_value_pair_buf,
    })
}

/// This event is generated in response to a Read Request.
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttReadResponse {
    /// The connection handle related to the response.
    pub conn_handle: ConnectionHandle,

    /// The number of valid bytes in the value buffer.
    value_len: usize,

    /// Buffer containing the value data.
    value_buf: [u8; MAX_READ_RESPONSE_LEN],
}

// The maximum amount of data in the buffer is the max HCI packet size (255) less the other data in
// the packet.
const MAX_READ_RESPONSE_LEN: usize = 250;

impl Debug for AttReadResponse {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(
            f,
            "{{.conn_handle = {:?}, value = {:?}}}",
            self.conn_handle,
            first_16(self.value())
        )
    }
}

impl AttReadResponse {
    /// Returns the valid part of the value data.
    pub fn value(&self) -> &[u8] {
        &self.value_buf[..self.value_len]
    }
}

fn to_att_read_response(buffer: &[u8]) -> Result<AttReadResponse, crate::event::Error> {
    require_len_at_least!(buffer, 5);

    let data_len = buffer[4] as usize;
    require_len!(buffer, 5 + data_len);

    let mut value_buf = [0; MAX_READ_RESPONSE_LEN];
    value_buf[..data_len].copy_from_slice(&buffer[5..]);

    Ok(AttReadResponse {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        value_len: data_len,
        value_buf,
    })
}

/// This event is generated in response to a Read By Group Type Request. See the Bluetooth Core v4.1
/// spec, Vol 3, section 3.4.4.9 and 3.4.4.10.
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttReadByGroupTypeResponse {
    ///  The connection handle related to the response.
    pub conn_handle: ConnectionHandle,

    // Length of the attribute data group in `attribute_data_buf`, including the attribute and group
    // end handles.
    attribute_group_len: usize,

    // Number of valid bytes in `attribute_data_buf`
    data_len: usize,

    // List of attribute data which is a repetition of:
    // 1. 2 octets for attribute handle.
    // 2. 2 octets for end group handle.
    // 3. (attribute_group_len - 4) octets for attribute value.
    attribute_data_buf: [u8; MAX_ATTRIBUTE_DATA_BUF_LEN],
}

// The maximum amount of data in the buffer is the max HCI packet size (255) less the other data in
// the packet.
const MAX_ATTRIBUTE_DATA_BUF_LEN: usize = 249;

impl AttReadByGroupTypeResponse {
    /// Create and return an iterator for the attribute data returned with the response.
    pub fn attribute_data_iter(&self) -> AttributeDataIterator {
        AttributeDataIterator {
            event: self,
            next_index: 0,
        }
    }
}

impl Debug for AttReadByGroupTypeResponse {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(f, "{{.conn_handle = {:?}, ", self.conn_handle)?;
        for attribute_data in self.attribute_data_iter() {
            write!(
                f,
                "{{.attribute_handle = {:?}, .attribute_end_handle = {:?}, .value = {:?}}}",
                attribute_data.attribute_handle,
                attribute_data.attribute_end_handle,
                first_16(attribute_data.value)
            )?;
        }
        write!(f, "}}")
    }
}

/// Iterator over the attribute data returned in the [`AttReadByGroupTypeResponse`].
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttributeDataIterator<'a> {
    event: &'a AttReadByGroupTypeResponse,
    next_index: usize,
}

impl<'a> Iterator for AttributeDataIterator<'a> {
    type Item = AttributeData<'a>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.next_index >= self.event.data_len {
            return None;
        }

        let attr_handle_index = self.next_index;
        let group_end_index = 2 + attr_handle_index;
        let value_index = 2 + group_end_index;
        self.next_index += self.event.attribute_group_len;
        Some(AttributeData {
            attribute_handle: AttributeHandle(LittleEndian::read_u16(
                &self.event.attribute_data_buf[attr_handle_index..],
            )),
            attribute_end_handle: AttributeHandle(LittleEndian::read_u16(
                &self.event.attribute_data_buf[group_end_index..],
            )),
            value: &self.event.attribute_data_buf[value_index..self.next_index],
        })
    }
}

/// Attribute data returned in the [`AttReadByGroupTypeResponse`] event.
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttributeData<'a> {
    /// Attribute handle
    pub attribute_handle: AttributeHandle,
    /// Group end handle
    pub attribute_end_handle: AttributeHandle,
    /// Attribute value
    pub value: &'a [u8],
}

impl<'a> AttributeData<'a> {
    pub fn uuid(&self) -> u16 {
        LittleEndian::read_u16(&self.value[0..])
    }
}

fn to_att_read_by_group_type_response(
    buffer: &[u8],
) -> Result<AttReadByGroupTypeResponse, crate::event::Error> {
    require_len_at_least!(buffer, 6);

    let data_len = buffer[5] as usize;
    require_len!(buffer, 6 + data_len);

    let attribute_group_len = buffer[4] as usize;

    if buffer[6..].len() % attribute_group_len != 0 {
        return Err(crate::event::Error::Vendor(
            VendorError::AttReadByGroupTypeResponsePartial,
        ));
    }

    let mut attribute_data_buf = [0; MAX_ATTRIBUTE_DATA_BUF_LEN];
    attribute_data_buf[..data_len].copy_from_slice(&buffer[6..]);
    Ok(AttReadByGroupTypeResponse {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        data_len, // lose 1 byte to attribute_group_len
        attribute_group_len,
        attribute_data_buf,
    })
}

/// This event is generated in response to a Prepare Write Request. See the Bluetooth Core v4.1
/// spec, Vol 3, Part F, section 3.4.6.1 and 3.4.6.2
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttPrepareWriteResponse {
    /// The connection handle related to the response.
    pub conn_handle: ConnectionHandle,
    /// The handle of the attribute to be written.
    pub attribute_handle: AttributeHandle,
    /// The offset of the first octet to be written.
    pub offset: usize,

    /// Number of valid bytes in |value_buf|
    value_len: usize,
    value_buf: [u8; MAX_WRITE_RESPONSE_VALUE_LEN],
}

// The maximum amount of data in the buffer is the max HCI packet size (255) less the other data in
// the packet.
const MAX_WRITE_RESPONSE_VALUE_LEN: usize = 246;

impl Debug for AttPrepareWriteResponse {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(
            f,
            "{{.conn_handle = {:?}, .attribute_handle = {:?}, .offset = {}, .value = {:?}}}",
            self.conn_handle,
            self.attribute_handle,
            self.offset,
            first_16(self.value())
        )
    }
}

impl AttPrepareWriteResponse {
    /// Returns the partial value of the attribute to be written.
    pub fn value(&self) -> &[u8] {
        &self.value_buf[..self.value_len]
    }
}

fn to_att_prepare_write_response(
    buffer: &[u8],
) -> Result<AttPrepareWriteResponse, crate::event::Error> {
    require_len_at_least!(buffer, 9);

    let data_len = buffer[4] as usize;
    require_len!(buffer, 5 + data_len);

    let value_len = data_len - 4;
    let mut value_buf = [0; MAX_WRITE_RESPONSE_VALUE_LEN];
    value_buf[..value_len].copy_from_slice(&buffer[9..]);
    Ok(AttPrepareWriteResponse {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        attribute_handle: AttributeHandle(LittleEndian::read_u16(&buffer[5..])),
        offset: LittleEndian::read_u16(&buffer[7..]) as usize,
        value_len,
        value_buf,
    })
}

/// Defines the attribute value returned by a [GATT Indication](VendorEvent::GattIndication) or
/// [GATT Notification](VendorEvent::GattNotification) event.
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttributeValue {
    /// The connection handle related to the event.
    pub conn_handle: ConnectionHandle,
    /// The handle of the attribute.
    pub attribute_handle: AttributeHandle,

    // Number of valid bytes in value_buf
    value_len: usize,
    // Current value of the attribute. Only the first value_len bytes are valid.
    value_buf: [u8; MAX_ATTRIBUTE_VALUE_LEN],
}

// The maximum amount of data in the buffer is the max HCI packet size (255) less the other data in
// the packet.
const MAX_ATTRIBUTE_VALUE_LEN: usize = 248;

impl Debug for AttributeValue {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(
            f,
            "{{.conn_handle = {:?}, .attribute_handle = {:?}, .value = {:?}}}",
            self.conn_handle,
            self.attribute_handle,
            first_16(self.value())
        )
    }
}

impl AttributeValue {
    /// Returns the current value of the attribute.
    pub fn value(&self) -> &[u8] {
        &self.value_buf[..self.value_len]
    }
}

fn to_attribute_value(buffer: &[u8]) -> Result<AttributeValue, crate::event::Error> {
    require_len_at_least!(buffer, 7);

    let value_len = buffer[6] as usize;
    require_len!(buffer, 7 + value_len);

    let mut value_buf = [0; MAX_ATTRIBUTE_VALUE_LEN];
    value_buf[..value_len].copy_from_slice(&buffer[7..]);
    Ok(AttributeValue {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        attribute_handle: AttributeHandle(LittleEndian::read_u16(&buffer[4..])),
        value_len,
        value_buf,
    })
}

fn to_write_permit_request(buffer: &[u8]) -> Result<AttributeValue, crate::event::Error> {
    require_len_at_least!(buffer, 7);

    let data_len = buffer[6] as usize;
    require_len!(buffer, 7 + data_len);

    let value_len = data_len;
    let mut value_buf = [0; MAX_ATTRIBUTE_VALUE_LEN];
    value_buf[..value_len].copy_from_slice(&buffer[7..]);
    Ok(AttributeValue {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        attribute_handle: AttributeHandle(LittleEndian::read_u16(&buffer[4..])),
        value_len,
        value_buf,
    })
}

/// This event is generated when a GATT client procedure completes either with error or
/// successfully.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct GattProcedureComplete {
    /// The connection handle for which the GATT procedure has completed.
    pub conn_handle: ConnectionHandle,

    /// Indicates whether the procedure completed with [error](GattProcedureStatus::Failed) or was
    /// [successful](GattProcedureStatus::Success).
    pub status: GattProcedureStatus,
}

/// Allowed status codes for the [GATT Procedure Complete](VendorEvent::GattProcedureComplete)
/// event.
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum GattProcedureStatus {
    /// BLE Status Success
    Success,
    /// BLE Status Failed
    Failed,
}

impl TryFrom<u8> for GattProcedureStatus {
    type Error = crate::event::Error;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x00 => Ok(GattProcedureStatus::Success),
            0x41 => Ok(GattProcedureStatus::Failed),
            _ => Err(crate::event::Error::Vendor(
                VendorError::BadGattProcedureStatus(value),
            )),
        }
    }
}

fn to_gatt_procedure_complete(buffer: &[u8]) -> Result<GattProcedureComplete, crate::event::Error> {
    require_len!(buffer, 5);

    Ok(GattProcedureComplete {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        status: buffer[4].try_into()?,
    })
}

/// The Error Response is used to state that a given request cannot be performed, and to provide the
/// reason. See the Bluetooth Core Specification, v4.1, Vol 3, Part F, Section 3.4.1.1.
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttErrorResponse {
    /// The connection handle related to the event.
    pub conn_handle: ConnectionHandle,
    /// The request that generated this error response.
    pub request: AttRequest,
    ///The attribute handle that generated this error response.
    pub attribute_handle: AttributeHandle,
    /// The reason why the request has generated an error response.
    pub error: AttError,
}

/// Potential error codes for the [ATT Error Response](VendorEvent::AttErrorResponse). See Table
/// 3.3 in the Bluetooth Core Specification, v4.1, Vol 3, Part F, Section 3.4.1.1 and The Bluetooth
/// Core Specification Supplement, Table 1.1.
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum AttError {
    /// The attribute handle given was not valid on this server.
    InvalidHandle = 0x01,
    /// The attribute cannot be read.
    ReadNotPermitted = 0x02,
    /// The attribute cannot be written.
    WriteNotPermitted = 0x03,
    /// The attribute PDU was invalid.
    InvalidPdu = 0x04,
    /// The attribute requires authentication before it can be read or written.
    InsufficientAuthentication = 0x05,
    /// Attribute server does not support the request received from the client.
    RequestNotSupported = 0x06,
    /// Offset specified was past the end of the attribute.
    InvalidOffset = 0x07,
    /// The attribute requires authorization before it can be read or written.
    InsufficientAuthorization = 0x08,
    /// Too many prepare writes have been queued.
    PrepareQueueFull = 0x09,
    /// No attribute found within the given attribute handle range.
    AttributeNotFound = 0x0A,
    /// The attribute cannot be read or written using the Read Blob Request.
    AttributeNotLong = 0x0B,
    /// The Encryption Key Size used for encrypting this link is insufficient.
    InsufficientEncryptionKeySize = 0x0C,
    /// The attribute value length is invalid for the operation.
    InvalidAttributeValueLength = 0x0D,
    /// The attribute request that was requested has encountered an error that was unlikely, and
    /// therefore could not be completed as requested.
    UnlikelyError = 0x0E,
    /// The attribute requires encryption before it can be read or written.
    InsufficientEncryption = 0x0F,
    /// The attribute type is not a supported grouping attribute as defined by a higher layer
    /// specification.
    UnsupportedGroupType = 0x10,
    /// Insufficient Resources to complete the request.
    InsufficientResources = 0x11,
    /// Database out of sync
    DatabaseOutOfSync = 0x12,
    /// Value not allowed
    ValueNotAllowed = 0x13,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x80 = 0x80,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x81 = 0x81,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x82 = 0x82,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x83 = 0x83,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x84 = 0x84,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x85 = 0x85,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x86 = 0x86,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x87 = 0x87,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x88 = 0x88,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x89 = 0x89,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x8A = 0x8A,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x8B = 0x8B,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x8C = 0x8C,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x8D = 0x8D,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x8E = 0x8E,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x8F = 0x8F,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x90 = 0x90,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x91 = 0x91,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x92 = 0x92,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x93 = 0x93,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x94 = 0x94,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x95 = 0x95,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x96 = 0x96,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x97 = 0x97,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x98 = 0x98,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x99 = 0x99,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x9A = 0x9A,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x9B = 0x9B,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x9C = 0x9C,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x9D = 0x9D,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x9E = 0x9E,
    /// Application error code defined by a higher layer specification.
    ApplicationError0x9F = 0x9F,
    /// The requested write operation cannot be fulfilled for reasons other than permissions.
    WriteRequestRejected = 0xFC,
    /// A Client Characteristic Configuration descriptor is not configured according to the
    /// requirements of the profile or service.
    ClientCharacteristicConfigurationDescriptorImproperlyConfigured = 0xFD,
    /// A profile or service request cannot be serviced because an operation that has been
    /// previously triggered is still in progress.
    ProcedureAlreadyInProgress = 0xFE,
    /// An attribute value is out of range as defined by a profile or service specification.
    OutOfRange = 0xFF,
}

impl TryFrom<u8> for AttError {
    type Error = u8;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x01 => Ok(AttError::InvalidHandle),
            0x02 => Ok(AttError::ReadNotPermitted),
            0x03 => Ok(AttError::WriteNotPermitted),
            0x04 => Ok(AttError::InvalidPdu),
            0x05 => Ok(AttError::InsufficientAuthentication),
            0x06 => Ok(AttError::RequestNotSupported),
            0x07 => Ok(AttError::InvalidOffset),
            0x08 => Ok(AttError::InsufficientAuthorization),
            0x09 => Ok(AttError::PrepareQueueFull),
            0x0A => Ok(AttError::AttributeNotFound),
            0x0B => Ok(AttError::AttributeNotLong),
            0x0C => Ok(AttError::InsufficientEncryptionKeySize),
            0x0D => Ok(AttError::InvalidAttributeValueLength),
            0x0E => Ok(AttError::UnlikelyError),
            0x0F => Ok(AttError::InsufficientEncryption),
            0x10 => Ok(AttError::UnsupportedGroupType),
            0x11 => Ok(AttError::InsufficientResources),
            0x80 => Ok(AttError::ApplicationError0x80),
            0x81 => Ok(AttError::ApplicationError0x81),
            0x82 => Ok(AttError::ApplicationError0x82),
            0x83 => Ok(AttError::ApplicationError0x83),
            0x84 => Ok(AttError::ApplicationError0x84),
            0x85 => Ok(AttError::ApplicationError0x85),
            0x86 => Ok(AttError::ApplicationError0x86),
            0x87 => Ok(AttError::ApplicationError0x87),
            0x88 => Ok(AttError::ApplicationError0x88),
            0x89 => Ok(AttError::ApplicationError0x89),
            0x8A => Ok(AttError::ApplicationError0x8A),
            0x8B => Ok(AttError::ApplicationError0x8B),
            0x8C => Ok(AttError::ApplicationError0x8C),
            0x8D => Ok(AttError::ApplicationError0x8D),
            0x8E => Ok(AttError::ApplicationError0x8E),
            0x8F => Ok(AttError::ApplicationError0x8F),
            0x90 => Ok(AttError::ApplicationError0x90),
            0x91 => Ok(AttError::ApplicationError0x91),
            0x92 => Ok(AttError::ApplicationError0x92),
            0x93 => Ok(AttError::ApplicationError0x93),
            0x94 => Ok(AttError::ApplicationError0x94),
            0x95 => Ok(AttError::ApplicationError0x95),
            0x96 => Ok(AttError::ApplicationError0x96),
            0x97 => Ok(AttError::ApplicationError0x97),
            0x98 => Ok(AttError::ApplicationError0x98),
            0x99 => Ok(AttError::ApplicationError0x99),
            0x9A => Ok(AttError::ApplicationError0x9A),
            0x9B => Ok(AttError::ApplicationError0x9B),
            0x9C => Ok(AttError::ApplicationError0x9C),
            0x9D => Ok(AttError::ApplicationError0x9D),
            0x9E => Ok(AttError::ApplicationError0x9E),
            0x9F => Ok(AttError::ApplicationError0x9F),
            0xFC => Ok(AttError::WriteRequestRejected),
            0xFD => Ok(AttError::ClientCharacteristicConfigurationDescriptorImproperlyConfigured),
            0xFE => Ok(AttError::ProcedureAlreadyInProgress),
            0xFF => Ok(AttError::OutOfRange),
            _ => Err(value),
        }
    }
}

/// Possible ATT requests.  See Table 3.37 in the Bluetooth Core Spec v4.1, Vol 3, Part F, Section
/// 3.4.8.
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum AttRequest {
    /// Section 3.4.1.1
    ErrorResponse = 0x01,
    /// Section 3.4.2.1
    ExchangeMtuRequest = 0x02,
    /// Section 3.4.2.2
    ExchangeMtuResponse = 0x03,
    /// Section 3.4.3.1
    FindInformationRequest = 0x04,
    /// Section 3.4.3.2
    FindInformationResponse = 0x05,
    /// Section 3.4.3.3
    FindByTypeValueRequest = 0x06,
    /// Section 3.4.3.4
    FindByTypeValueResponse = 0x07,
    /// Section 3.4.4.1
    ReadByTypeRequest = 0x08,
    /// Section 3.4.4.2
    ReadByTypeResponse = 0x09,
    /// Section 3.4.4.3
    ReadRequest = 0x0A,
    /// Section 3.4.4.4
    ReadResponse = 0x0B,
    /// Section 3.4.4.5
    ReadBlobRequest = 0x0C,
    /// Section 3.4.4.6
    ReadBlobResponse = 0x0D,
    /// Section 3.4.4.7
    ReadMultipleRequest = 0x0E,
    /// Section 3.4.4.8
    ReadMultipleResponse = 0x0F,
    /// Section 3.4.4.9
    ReadByGroupTypeRequest = 0x10,
    /// Section 3.4.4.10
    ReadByGroupTypeResponse = 0x11,
    /// Section 3.4.5.1
    WriteRequest = 0x12,
    /// Section 3.4.5.2
    WriteResponse = 0x13,
    /// Section 3.4.5.3
    WriteCommand = 0x52,
    /// Section 3.4.5.4
    SignedWriteCommand = 0xD2,
    /// Section 3.4.6.1
    PrepareWriteRequest = 0x16,
    /// Section 3.4.6.2
    PrepareWriteResponse = 0x17,
    /// Section 3.4.6.3
    ExecuteWriteRequest = 0x18,
    /// Section 3.4.6.4
    ExecuteWriteResponse = 0x19,
    /// Section 3.4.7.1
    HandleValueNotification = 0x1B,
    /// Section 3.4.7.2
    HandleValueIndication = 0x1D,
    /// Section 3.4.7.3
    HandleValueConfirmation = 0x1E,
}

impl TryFrom<u8> for AttRequest {
    type Error = VendorError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x01 => Ok(AttRequest::ErrorResponse),
            0x02 => Ok(AttRequest::ExchangeMtuRequest),
            0x03 => Ok(AttRequest::ExchangeMtuResponse),
            0x04 => Ok(AttRequest::FindInformationRequest),
            0x05 => Ok(AttRequest::FindInformationResponse),
            0x06 => Ok(AttRequest::FindByTypeValueRequest),
            0x07 => Ok(AttRequest::FindByTypeValueResponse),
            0x08 => Ok(AttRequest::ReadByTypeRequest),
            0x09 => Ok(AttRequest::ReadByTypeResponse),
            0x0A => Ok(AttRequest::ReadRequest),
            0x0B => Ok(AttRequest::ReadResponse),
            0x0C => Ok(AttRequest::ReadBlobRequest),
            0x0D => Ok(AttRequest::ReadBlobResponse),
            0x0E => Ok(AttRequest::ReadMultipleRequest),
            0x0F => Ok(AttRequest::ReadMultipleResponse),
            0x10 => Ok(AttRequest::ReadByGroupTypeRequest),
            0x11 => Ok(AttRequest::ReadByGroupTypeResponse),
            0x12 => Ok(AttRequest::WriteRequest),
            0x13 => Ok(AttRequest::WriteResponse),
            0x52 => Ok(AttRequest::WriteCommand),
            0xD2 => Ok(AttRequest::SignedWriteCommand),
            0x16 => Ok(AttRequest::PrepareWriteRequest),
            0x17 => Ok(AttRequest::PrepareWriteResponse),
            0x18 => Ok(AttRequest::ExecuteWriteRequest),
            0x19 => Ok(AttRequest::ExecuteWriteResponse),
            0x1B => Ok(AttRequest::HandleValueNotification),
            0x1D => Ok(AttRequest::HandleValueIndication),
            0x1E => Ok(AttRequest::HandleValueConfirmation),
            _ => Err(VendorError::BadAttRequestOpcode(value)),
        }
    }
}

fn to_att_error_response(buffer: &[u8]) -> Result<AttErrorResponse, crate::event::Error> {
    require_len!(buffer, 8);
    Ok(AttErrorResponse {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        request: buffer[4].try_into().map_err(crate::event::Error::Vendor)?,
        attribute_handle: AttributeHandle(LittleEndian::read_u16(&buffer[5..])),
        error: buffer[7]
            .try_into()
            .map_err(VendorError::BadAttError)
            .map_err(crate::event::Error::Vendor)?,
    })
}

/// This event is given to the application when a read request or read blob request is received by
/// the server from the client. This event will be given to the application only if the event bit
/// for this event generation is set when the characteristic was added. On receiving this event, the
/// application can update the value of the handle if it desires and when done it has to use the
/// [`allow_read`](crate::vendor::command::gatt::GattCommands::allow_read) command to indicate to the stack that it can
/// send the response to the client.
///
/// See the Bluetooth Core v4.1 spec, Vol 3, Part F, section 3.4.4.
/// See STM AN5270, section 3.4.19
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttReadPermitRequest {
    /// Handle of the connection on which there was the request to read the attribute
    pub conn_handle: ConnectionHandle,

    /// The handle of the attribute that has been requested by the client to be read.
    pub attribute_handle: AttributeHandle,

    /// Contains the offset from which the read has been requested.
    pub offset: usize,
}

fn to_att_read_permit_request(buffer: &[u8]) -> Result<AttReadPermitRequest, crate::event::Error> {
    require_len!(buffer, 8);
    Ok(AttReadPermitRequest {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        attribute_handle: AttributeHandle(LittleEndian::read_u16(&buffer[4..])),
        offset: LittleEndian::read_u16(&buffer[6..]) as usize,
    })
}

/// This event is given to the application when a read multiple request or read by type request is
/// received by the server from the client. This event will be given to the application only if the
/// event bit for this event generation is set when the characteristic was added.  On receiving this
/// event, the application can update the values of the handles if it desires and when done it has
/// to send the `gatt_allow_read` command to indicate to the stack that it can send the response to
/// the client.
///
/// See the Bluetooth Core v4.1 spec, Vol 3, Part F, section 3.4.4.
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttReadMultiplePermitRequest {
    /// Handle of the connection which requested to read the attribute.
    pub conn_handle: ConnectionHandle,

    /// Number of valid handles in handles_buf
    handles_len: usize,
    /// Attribute handles returned by the ATT Read Multiple Permit Request. Only the first
    /// `handles_len` handles are valid.
    handles_buf: [AttributeHandle; MAX_ATTRIBUTE_HANDLE_BUFFER_LEN],
}

// The maximum number of handles in the buffer is the max HCI packet size (255) less the other data in
// the packet divided by the length of an attribute handle (2).
const MAX_ATTRIBUTE_HANDLE_BUFFER_LEN: usize = 125;

impl Debug for AttReadMultiplePermitRequest {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(
            f,
            "{{.conn_handle = {:?}, .handles = {:?}",
            self.conn_handle,
            first_16(self.handles())
        )
    }
}

impl AttReadMultiplePermitRequest {
    /// Returns the valid attribute handles returned by the ATT Read Multiple Permit Request event.
    pub fn handles(&self) -> &[AttributeHandle] {
        &self.handles_buf[..self.handles_len]
    }
}

fn to_att_read_multiple_permit_request(
    buffer: &[u8],
) -> Result<AttReadMultiplePermitRequest, crate::event::Error> {
    require_len_at_least!(buffer, 5);

    let data_len = buffer[4] as usize;
    if data_len % 2 != 0 {
        return Err(crate::event::Error::Vendor(
            VendorError::AttReadMultiplePermitRequestPartial,
        ));
    }

    let handle_len = data_len / 2;
    let mut handles = [AttributeHandle(0); MAX_ATTRIBUTE_HANDLE_BUFFER_LEN];
    for (i, handle) in handles.iter_mut().enumerate().take(handle_len) {
        let index = 5 + 2 * i;
        *handle = AttributeHandle(LittleEndian::read_u16(&buffer[index..]));
    }

    Ok(AttReadMultiplePermitRequest {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        handles_len: handle_len,
        handles_buf: handles,
    })
}

/// This event is raised when the number of available TX buffers is above a threshold TH (TH = 2).
/// The event will be given only if a previous ACI command returned with
/// [`InsufficientResources`](AttError::InsufficientResources).
#[derive(Copy, Clone, Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct GattTxPoolAvailable {
    /// Connection handle on which the GATT procedure is running.
    pub conn_handle: ConnectionHandle,
    /// Indicates the number of elements available in the attrTxPool List.
    pub available_buffers: usize,
}

fn to_gatt_tx_pool_available(buffer: &[u8]) -> Result<GattTxPoolAvailable, crate::event::Error> {
    require_len!(buffer, 6);
    Ok(GattTxPoolAvailable {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        available_buffers: LittleEndian::read_u16(&buffer[4..]) as usize,
    })
}

/// This event is given to the application when a prepare write request is received by the server
/// from the client.
///
/// This event will be given to the application only if the event bit for this event generation is
/// set when the characteristic was added.  When this event is received, the application has to
/// check whether the value being requested for write is allowed to be written and respond with the
/// command `gatt_write_response`.  Based on the response from the application, the attribute value
/// will be modified by the stack.  If the write is rejected by the application, then the value of
/// the attribute will not be modified and an error response will be sent to the client, with the
/// error code as specified by the application.
#[derive(Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct AttPrepareWritePermitRequest {
    /// Connection handle on which the GATT procedure is running.
    pub conn_handle: ConnectionHandle,
    /// The handle of the attribute to be written.
    pub attribute_handle: AttributeHandle,
    /// The offset of the first octet to be written.
    pub offset: usize,

    // Number of valid bytes in `value_buf`
    value_len: usize,
    // The data to be written. Only the first `value_len` bytes are valid.
    value_buf: [u8; MAX_PREPARE_WRITE_PERMIT_REQ_VALUE_LEN],
}

// The maximum number of bytes in the buffer is the max HCI packet size (255) less the other data in
// the packet.
const MAX_PREPARE_WRITE_PERMIT_REQ_VALUE_LEN: usize = 246;

impl Debug for AttPrepareWritePermitRequest {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        write!(
            f,
            "{{.conn_handle = {:?}, .attribute_handle = {:?}, .offset = {:?}, .value = {:?}",
            self.conn_handle,
            self.attribute_handle,
            self.offset,
            first_16(self.value())
        )
    }
}

impl AttPrepareWritePermitRequest {
    /// Returns the data to be written.
    pub fn value(&self) -> &[u8] {
        &self.value_buf[..self.value_len]
    }
}

fn to_att_prepare_write_permit_request(
    buffer: &[u8],
) -> Result<AttPrepareWritePermitRequest, crate::event::Error> {
    require_len_at_least!(buffer, 9);

    let data_len = buffer[8] as usize;
    require_len!(buffer, 9 + data_len);

    let mut value_buf = [0; MAX_PREPARE_WRITE_PERMIT_REQ_VALUE_LEN];
    value_buf[..data_len].copy_from_slice(&buffer[9..]);
    Ok(AttPrepareWritePermitRequest {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        attribute_handle: AttributeHandle(LittleEndian::read_u16(&buffer[4..])),
        offset: LittleEndian::read_u16(&buffer[6..]) as usize,
        value_len: data_len,
        value_buf,
    })
}

/// This event is sent only during SC Pairing, when Numeric Comparison
/// Association model is selected, in order to show the Numeric Value generated,
/// and to ask for Confirmation to the User. When this event is received, the
/// application has to respond with the
/// [numeric_comparison_value_confirm_yes_no](super::command::gap::GapCommands::numeric_comparison_value_confirm_yes_no)
/// command.
#[derive(Debug, Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct GapNumericComparisonValue {
    /// Handle of the connection where this event occured
    pub connection_handle: ConnectionHandle,
    /// Generated numeric value
    pub numeric_value: u32,
}

fn to_numeric_comparison_value(
    buffer: &[u8],
) -> Result<GapNumericComparisonValue, crate::event::Error> {
    require_len!(buffer, 8);

    Ok(GapNumericComparisonValue {
        connection_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])),
        numeric_value: LittleEndian::read_u32(&buffer[4..]),
    })
}

#[derive(Debug, Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// This event is sent only during SC Pairing, when Keypress Notifications are
/// supported, in order to show the input type signaled by the peer device,
/// having Keyboard only I/O capabilities. When this event is received, no
/// action is required to the User.
pub struct GapKeypressNotification {
    /// Handle of the connection where this event occured
    pub connection_handle: ConnectionHandle,
    /// Type of Keypress input notified/signaled by peer device
    /// (having Keyboard only I/O capabilities.
    pub notification_type: KeypressNotificationType,
}

#[derive(Debug, Copy, Clone)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// Type of Keypress input notified/signaled by peer device
/// (having Keyboard only I/O capabilities.
pub enum KeypressNotificationType {
    EntryStarted = 0x00,
    DigitEntered = 0x01,
    DigitErased = 0x02,
    PasskeyCleared = 0x03,
    EntryCompleted = 0x04,
    Reserved,
}

impl From<u8> for KeypressNotificationType {
    fn from(value: u8) -> Self {
        match value {
            0x00 => KeypressNotificationType::EntryStarted,
            0x01 => KeypressNotificationType::DigitEntered,
            0x02 => KeypressNotificationType::DigitErased,
            0x03 => KeypressNotificationType::PasskeyCleared,
            0x04 => KeypressNotificationType::EntryCompleted,
            _ => KeypressNotificationType::Reserved,
        }
    }
}

fn to_keypress_notification(buffer: &[u8]) -> Result<GapKeypressNotification, crate::event::Error> {
    require_len!(buffer, 3);

    Ok(GapKeypressNotification {
        connection_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[0..])),
        notification_type: KeypressNotificationType::from(buffer[2]),
    })
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// This event is generated upon receipt of a valid Command Reject packet (e.g.
/// when the Central responds to the Connection Update Request packet with a
/// Command Reject packet).
pub struct L2CapCommandReject {
    /// Handle of the connection where this event occurred
    pub conn_handle: ConnectionHandle,
    /// This is the identifier which associate the request to the response.
    pub identifier: u8,
    /// Reason
    pub reason: u16,
    /// Data field associated with Reason
    pub data: [u8; 247],
}

fn to_l2cap_command_reject(buffer: &[u8]) -> Result<L2CapCommandReject, crate::event::Error> {
    require_len_at_least!(buffer, 6);

    let mut data = [0; 247];
    let len = buffer[5] as usize;
    data[..len].copy_from_slice(&buffer[6..(6 + len)]);

    Ok(L2CapCommandReject {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[0..])),
        identifier: buffer[2],
        reason: LittleEndian::read_u16(&buffer[3..]),
        data,
    })
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// This event informs the application of a change in status of the Enhanced ATT
/// bearer handled by the specified L2CAP channel
pub struct GattEattBrearer {
    /// Index of the connection-oriented channel for which the primitive applies.
    pub channel_index: u8,
    /// Enhanced ATT bearer state.
    pub eab_state: EabState,
    /// Status error code
    pub status: GattProcedureStatus,
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// Enhanced ATT bearer state.
pub enum EabState {
    AttBearerCreated = 0x00,
    AttBearerTerminated = 0x01,
}

impl TryFrom<u8> for EabState {
    type Error = crate::event::Error;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x00 => Ok(EabState::AttBearerCreated),
            0x01 => Ok(EabState::AttBearerTerminated),
            err => Err(crate::event::Error::Vendor(VendorError::BadEabState(err))),
        }
    }
}

fn to_gatt_eatt_bearer(buffer: &[u8]) -> Result<GattEattBrearer, crate::event::Error> {
    require_len!(buffer, 3);

    Ok(GattEattBrearer {
        channel_index: buffer[0],
        eab_state: EabState::try_from(buffer[1])?,
        status: GattProcedureStatus::try_from(buffer[2])?,
    })
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// This event is generated when a Multiple Handle Value Notification is received from the server.
pub struct GattMultiNotification {
    /// Specifies the ATT bearer for which the event
    pub conn_handle: ConnectionHandle,
    /// - Bits 14-0: offset in octets from which Attribute_Value data starts.
    /// - Bit 15 is used as flag: when set to 1 it indicates what more data are to come
    /// (fragmented event in case of long attribute data)
    pub offset: u16,
    /// Length of the data in bytes
    pub data_len: u16,
    /// List of "Handle Length Value" tuples as define in Bluetooth Core Specification
    pub data: [u8; 247],
}

fn to_gatt_multi_notification(buffer: &[u8]) -> Result<GattMultiNotification, crate::event::Error> {
    require_len_at_least!(buffer, 6);

    let data_len = LittleEndian::read_u16(&buffer[4..]);
    let mut data = [0; 247];
    data[..data_len as usize].copy_from_slice(&buffer[4..]);

    Ok(GattMultiNotification {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[0..])),
        offset: LittleEndian::read_u16(&buffer[2..]),
        data_len,
        data,
    })
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// Defines data returned by [GATT Read Ext](VendorEvent::GattReadExt) event
pub struct GattReadExt {
    /// The connection handle related to the event.
    pub conn_handle: ConnectionHandle,
    /// - Bits 14-0: offset in octets from which Attribute_Value data
    /// starts.
    /// - Bit 15 is used as flag: when set to 1 it indicates that more
    /// data are to come (fragmented event in case of long attribute data).
    pub offset: u16,

    // Number of valid bytes in value_buf
    value_len: usize,
    // Current value of the attribute. Only the first value_len bytes are valid.
    value_buf: [u8; MAX_ATTRIBUTE_VALUE_LEN],
}

fn to_gatt_read_ext(buffer: &[u8]) -> Result<GattReadExt, crate::event::Error> {
    require_len_at_least!(buffer, 6);

    let value_len = LittleEndian::read_u16(&buffer[4..]) as usize;
    require_len!(buffer, 6 + value_len);

    let mut value_buf = [0; MAX_ATTRIBUTE_VALUE_LEN];
    value_buf[..value_len].copy_from_slice(&buffer[6..]);

    Ok(GattReadExt {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[0..])),
        offset: LittleEndian::read_u16(&buffer[2..]),
        value_len,
        value_buf,
    })
}

impl GattReadExt {
    pub fn value(&self) -> &[u8] {
        &self.value_buf[..self.value_len]
    }
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// Defines data returned by [GATT Indication Ext](VendorEvent::GattIndicationExt) or
/// [GATT Notification Ext](VendorEvent::GattNotificationExt) event
pub struct AttributeValueExt {
    /// The connection handle related to the event.
    pub conn_handle: ConnectionHandle,
    /// The handle of the attribute
    pub attribute_handle: AttributeHandle,
    /// - Bits 14-0: offset in octets from which Attribute_Value data
    /// starts.
    /// - Bit 15 is used as flag: when set to 1 it indicates that more
    /// data are to come (fragmented event in case of long attribute data).
    pub offset: u16,

    // Number of valid bytes in value_buf
    value_len: usize,
    // Current value of the attribute. Only the first value_len bytes are valid.
    value_buf: [u8; MAX_ATTRIBUTE_VALUE_LEN],
}

fn to_attribute_value_ext(buffer: &[u8]) -> Result<AttributeValueExt, crate::event::Error> {
    require_len_at_least!(buffer, 6);

    let value_len = LittleEndian::read_u16(&buffer[6..]) as usize;
    require_len!(buffer, 8 + value_len);

    let mut value_buf = [0; MAX_ATTRIBUTE_VALUE_LEN];
    value_buf[..value_len].copy_from_slice(&buffer[8..]);

    Ok(AttributeValueExt {
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[0..])),
        attribute_handle: AttributeHandle(LittleEndian::read_u16(&buffer[2..])),
        offset: LittleEndian::read_u16(&buffer[4..]),
        value_len,
        value_buf,
    })
}

impl AttributeValueExt {
    pub fn value(&self) -> &[u8] {
        &self.value_buf[..self.value_len]
    }
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// Defines data returned by [HAL End Of Radio Activity](VendorEvent::HalEndOfRadioActivity) event
pub struct HalEndOfRadioActivity {
    /// Completed radio event
    pub last_state: RadioEvent,
    /// Incoming radio event
    pub next_state: RadioEvent,
    /// 32-bit absolute current time expressed in internal time units
    pub next_state_sys_time: u32,
    /// Slot number of completed radio events
    ///
    /// Values:
    /// - 0xFF: Idle
    /// - 0x00 .. 0x07
    pub last_state_slot: u8,
    /// Slot number of incoming radio events
    ///
    /// Values:
    /// - 0xFF: Idle
    /// - 0x00 .. 0x07
    pub next_state_slot: u8,
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum RadioEvent {
    Idle = 0x00,
    Advertising = 0x01,
    PeripheralConnection = 0x02,
    Scanning = 0x03,
    CentralConnection = 0x05,
    TxTestMode = 0x06,
    RxTestMode = 0x07,
}

impl TryFrom<u8> for RadioEvent {
    type Error = crate::event::Error;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x00 => Ok(RadioEvent::Idle),
            0x01 => Ok(RadioEvent::Advertising),
            0x02 => Ok(RadioEvent::PeripheralConnection),
            0x03 => Ok(RadioEvent::Scanning),
            0x05 => Ok(RadioEvent::CentralConnection),
            0x06 => Ok(RadioEvent::TxTestMode),
            0x07 => Ok(RadioEvent::RxTestMode),
            x => Err(crate::event::Error::Vendor(VendorError::BadRadioEvent(x))),
        }
    }
}

fn to_hal_end_of_radio_activity(
    buffer: &[u8],
) -> Result<HalEndOfRadioActivity, crate::event::Error> {
    require_len!(buffer, 7);

    Ok(HalEndOfRadioActivity {
        last_state: RadioEvent::try_from(buffer[0])?,
        next_state: RadioEvent::try_from(buffer[1])?,
        next_state_sys_time: LittleEndian::read_u32(&buffer[2..]),
        last_state_slot: buffer[6],
        next_state_slot: buffer[7],
    })
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// Defines data returned by [HAL End Of Radio Activity](VendorEvent::HalEndOfRadioActivity) event
pub struct HalScanReqReport {
    /// RSSI (signed integer).
    ///
    /// Units: dBm
    ///
    /// Values:
    /// - 127: RSSI not available
    /// - -127 .. 20
    pub rssi: u8,
    /// Address of the peer device
    pub peer_addr: PeerAddrType,
}

fn to_hal_scan_req_report(buffer: &[u8]) -> Result<HalScanReqReport, crate::event::Error> {
    require_len!(buffer, 8);

    let mut addr = crate::BdAddr([0; 6]);
    addr.0.copy_from_slice(&buffer[2..]);

    Ok(HalScanReqReport {
        rssi: buffer[0],
        peer_addr: match buffer[1] {
            0x00 => PeerAddrType::PublicDeviceAddress(addr),
            0x01 => PeerAddrType::RandomDeviceAddress(addr),
            0x02 => PeerAddrType::PublicDeviceAddress(addr),
            0x03 => PeerAddrType::RandomIdentityAddress(addr),
            x => return Err(crate::event::Error::Vendor(VendorError::BadBdAddrType(x))),
        },
    })
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// Defines data returned by [HAL Firmware Error](VendorEvent::HalFirmwareError) event
pub struct HalFirmwareError {
    /// Firmware error type
    pub fw_error_type: FirmwareError,
    /// Length of  data in octets
    data_len: u8,
    /// the error event info
    data: [u8; 251],
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
/// Defines error types returned by [HAL Firmware Error](VendorEvent::HalFirmwareError) event
pub enum FirmwareError {
    /// L2CAP recombination failure
    L2capRecombination = 0x01,
    /// GATT unexpected peer message
    GattUnexpectedPeerMsg = 0x02,
    /// NVM level warning
    NvmLevelWarning = 0x03,
    /// COC Rx data length too large
    CocRxDataTooLarge = 0x04,
}

impl TryFrom<u8> for FirmwareError {
    type Error = crate::event::Error;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0x01 => Ok(FirmwareError::L2capRecombination),
            0x02 => Ok(FirmwareError::GattUnexpectedPeerMsg),
            0x03 => Ok(FirmwareError::NvmLevelWarning),
            0x04 => Ok(FirmwareError::CocRxDataTooLarge),
            x => Err(crate::event::Error::Vendor(VendorError::BadFirmwareError(
                x,
            ))),
        }
    }
}

impl HalFirmwareError {
    pub fn data(&self) -> &[u8] {
        &self.data[..self.data_len as usize]
    }
}

fn to_hal_firmware_error(buffer: &[u8]) -> Result<HalFirmwareError, crate::event::Error> {
    require_len_at_least!(buffer, 2);

    let data_len = buffer[1] as usize;
    let mut data = [0; 251];
    data[..data_len].copy_from_slice(&buffer[2..(2 + data_len)]);

    Ok(HalFirmwareError {
        fw_error_type: FirmwareError::try_from(buffer[0])?,
        data_len: buffer[1],
        data,
    })
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct CocConnectEvent {
        /// The connection handle related to the event.
        pub conn_handle: ConnectionHandle,

        pub smps: u16,
        pub mtu: u16,
        pub mps: u16,
        pub initial_credits: u16,
        pub num_channels: u8,
}

fn to_l2cap_coc_connect(buffer: &[u8]) -> Result<CocConnectEvent, crate::event::Error> {
    require_len!(buffer, 13);

    Ok(CocConnectEvent{ 
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])), 
        smps: LittleEndian::read_u16(&buffer[4..]),
        mtu: LittleEndian::read_u16(&buffer[6..]),
        mps: LittleEndian::read_u16(&buffer[8..]),
        initial_credits: LittleEndian::read_u16(&buffer[10..]),
        num_channels: buffer[12] })
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct CocConnectConfirmEvent {
    /// The connection handle related to the event.
    pub conn_handle: ConnectionHandle,

    pub smps: u16,
    pub mtu: u16,
    pub mps: u16,
    pub results: u16,
        
    /// Handle for the channel indices
    value_buf: [u8; CocConnectConfirmEvent::MAX_NUM_CHANNELS],
    value_len: usize,
}

impl CocConnectConfirmEvent {
    const MAX_NUM_CHANNELS: usize = 5;

    /// Return the handle value. Only valid bytes are returned.
    pub fn channels(&self) -> &[u8] {
        &self.value_buf[..self.value_len]
    }
}

fn to_l2cap_coc_connect_confirm(buffer: &[u8]) -> Result<CocConnectConfirmEvent, crate::event::Error> {
    let mut event = CocConnectConfirmEvent{ 
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])), 
        smps: LittleEndian::read_u16(&buffer[4..]),
        mtu: LittleEndian::read_u16(&buffer[6..]),
        mps: LittleEndian::read_u16(&buffer[8..]),
        results: LittleEndian::read_u16(&buffer[10..]),
        value_buf: [0u8; CocConnectConfirmEvent::MAX_NUM_CHANNELS], value_len: buffer[12] as usize};

    if event.value_len > 0 {
        event.value_buf[..event.value_len].copy_from_slice(&buffer[13..]);
    }
    Ok(event)
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct CocReconfigEvent {
    /// The connection handle related to the event.
    pub conn_handle: ConnectionHandle,

    pub mtu: u16,
    pub mps: u16,
        
    /// Handle for the channel indices
    value_buf: [u8; CocReconfigEvent::MAX_NUM_CHANNELS],
    value_len: usize,
}

impl CocReconfigEvent {
    const MAX_NUM_CHANNELS: usize = 5;

    /// Return the handle value. Only valid bytes are returned.
    pub fn channels(&self) -> &[u8] {
        &self.value_buf[..self.value_len]
    }
}

fn to_l2cap_coc_reconfig(buffer: &[u8]) -> Result<CocReconfigEvent, crate::event::Error> {
    let mut event = CocReconfigEvent{ 
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])), 
        mtu: LittleEndian::read_u16(&buffer[4..]),
        mps: LittleEndian::read_u16(&buffer[6..]),
        value_buf: [0u8; CocConnectConfirmEvent::MAX_NUM_CHANNELS], value_len: buffer[8] as usize};

        if event.value_len > 0 {
            event.value_buf[..event.value_len].copy_from_slice(&buffer[9..]);
        }
        Ok(event)
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct CocReconfigConfirmEvent {
        /// The connection handle related to the event.
        pub conn_handle: ConnectionHandle,

        pub result: u16,
}

fn to_l2cap_coc_reconfig_confirm(buffer: &[u8]) -> Result<CocReconfigConfirmEvent, crate::event::Error> {
    Ok(CocReconfigConfirmEvent{ 
        conn_handle: ConnectionHandle(LittleEndian::read_u16(&buffer[2..])), 
        result: LittleEndian::read_u16(&buffer[4..]) })
}

#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct CocFlowControlEvent {
        pub channel_index: u8,
        pub credits: u16,
}

fn to_l2cap_coc_flow_control(buffer: &[u8]) -> Result<CocFlowControlEvent, crate::event::Error> {
    Ok(CocFlowControlEvent{ 
        channel_index: buffer[2], 
        credits: LittleEndian::read_u16(&buffer[3..]) })
}


#[derive(Debug, Clone, Copy)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct CocRxDataEvent {
    pub channel: u8,
        
    /// Handle for the channel indices
    value_buf: [u8; CocRxDataEvent::MAX_LENGTH],
    value_len: usize,
}

impl CocRxDataEvent {
    const MAX_LENGTH: usize = 248;

    /// Return the handle value. Only valid bytes are returned.
    pub fn data(&self) -> &[u8] {
        &self.value_buf[..self.value_len]
    }
}

fn to_l2cap_coc_rx_data(buffer: &[u8]) -> Result<CocRxDataEvent, crate::event::Error> {
    let mut event = CocRxDataEvent{ 
        channel: buffer[2], 
        value_buf: [0u8; CocRxDataEvent::MAX_LENGTH], value_len: usize::from(LittleEndian::read_u16(&buffer[3..]))};

    if event.value_len > 0 {
        event.value_buf[..event.value_len].copy_from_slice(&buffer[5..]);
    }
    Ok(event)
}
